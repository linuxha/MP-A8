* MP-A8

** Flex notes

*** Notes

**** Documents

https://github.com/nealcrook/multicomp6809/wiki/a-tour-of-the-FLEX-system-disk

| Document                      | Description                                         |
|-------------------------------+-----------------------------------------------------|
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/6809fadg.pdf][6809fadg.pdf]]                  | 6809 FLEX™ Adaptation Guide                         |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/f77.pdf][f77.pdf]]                       | Fortran 77 for 6809 FLEX                            |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/flex2um.pdf][flex2um.pdf]]                   | FLEX User Manual - Early version of FLEX 2 for 6800 |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/swflexum.pdf][swflexum.pdf]]                  | FLEX User Manual - Later version of FLEX 9 for 6809 |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/FLEXAPG.PDF][FLEXAPG.PDF]]                   | FLEX Programmer’s Manual - 6809 Version             |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/swtpcfgn.pdf][swtpcfgn.pdf]]                  | FLEX General Notes                                  |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/tedit.pdf][tedit.pdf]]                     | TSC Text Editor                                     |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/TSC_FLEX_BASIC.pdf][TSC_FLEX_BASIC.pdf]]            | TSC FLEX Basic                                      |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/TSC-6809-Assembler.pdf][TSC-6809-Assembler.pdf]]        | TSC 6809 Assembler                                  |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/TSC-6809-Flex-Diagnostics.pdf][TSC-6809-Flex-Diagnostics.pdf]] | TSC 6809 FLEX Diagnostics                           |
| [[https://s3.us-west-1.amazonaws.com/assets.simonwynn.com/flexdocs/TSC-Flex-Utilities.pdf][TSC-Flex-Utilities.pdf]]        | TSC FLEX Utilities                                  |

**** Requirements

- 8K @ $C000 (Flex OS - $C000-$DFFF)
- 12K @ $0000 (User, usually up to $BFFF max)
- Console
- Floppy interface
- Monitor ROM to boot to Flex (this usually has the IO routines)

|-------+------+--------+-----------------------|
| Begin | End  |        | Notes                 |
|-------+------+--------+-----------------------|
| 0000  | BFFF | x0xx x | RAM                   |
| C000  | DFFF | 110x x | Flex (RAM)            |
| E000  | EFFF | 111x x | xxxx                  |
|       |      | 111x x | I/O can go here       |
|       |      | 1110 x | SWTPC IO is here! :-) |
| F000  | FFFF | 1111 1 | ROM                   |
|-------+------+--------+-----------------------|

While not normal I/O tends to live at places like 8000 or A000 (74138 - 3 to 8 line decode)

74159 -

**** 6809 FLEX Memory Map

 C000 -------
 I    System Stack
 C080 -------
 I    Input Buffer
 C100 -------
 I
 I
 I    Utility Area
 I
 I
 C700 -------
 I
 I    Printer Spooler
 I
 C840 -------
 I
 I    System/User FCB
 I
 C980 -------
 I
 I         System I/O FCB's
 I    (FLEX Initialize at CA00)
 I
 CC00 -------
 I    System Variables
 CCC0 -------
 I    Printer Drivers
 CCF8 -------
 I    System Variables
 CD00 -------
 I
 I
 I    Disk Operating System
 I
 I
 D370 -------
 I    Console I/O Drivers
 D400 -------
 I
 I
 I    File Management-System
 I
 I
 I
 DE00 -------
 I
 I    Disk Drivers
 I
 E000 -------

**** 6502 Jump table

Interesting, might be useful for the 6800 but I hope for a better jump table.

https://retrocomputing.stackexchange.com/questions/17709/efficient-way-to-jmp-or-jsr-to-an-address-stored-somewhere-else
http://forum.6502.org/viewtopic.php?t=4897

I think 6800 has 'JMP  X'

*** Versions (6809 I think)

| VERSION                          | DATE      | SOURCE                    | COMMENTS                            |
| FLEX 2.0                         | none      | FL2_0SWT.DSK              | FLEX.COR presumably 6800 FLEX       |
| FLEX 2.0                         | none      | 6800FLEX.DSK              | FLEX.COR presumably 6800 FLEX       |
| FLEX - Version 2.8:1             | -         | SJT029.DSK                | FLEX.SYS                            |
| FLEX - Version 2.8:3             | -         | SJT007.DSK                | FLEX.SYS                            |
| FLEX - Version 2.9:1             | -         | Flex291.dsk               | FLEX.SYS                            |
| FLEX for MC6809 Version 2.9:2    | -         | FLEX9MST.DSK              | FLEX.SYS                            |
| FLEX for KP MC6809 Version 2.9:2 |           |                           | 56K                                 |
| ???                              |           | UNK4.DSK                  | FLEX.SYS                            |
| 6809 FLEX V3.01                  |           | FLEXSSB.DSK               | FLEX.SYS, Smoke Signal Broadcasting |
| FLEX V3.02                       |           | n/a                       | source listing, junkbox computer    |
| FLEX 9.0                         | 08Nov1979 | multicomp09_flex.dsk      | originally came from FLEX09BT.DSK   |
| FLEX 9.0                         | 10Feb1980 | DMAF2_BOOT_dsk            | FLEX.SYS                            |
| FLEX 9.0                         | none      | flexcmds.dsk              | FLEX.COR                            |
| FLEX 9.1                         | none      | TSCFLX09.DSK              | FLEX.COR, FLEX.SYS                  |
| FLEX 9.1                         | none      | original_flex09_AB168.dsk | FLEX.COR                            |
| FLEX 9.1                         | none      | original_flex09_AB178.dsk | FLEX.COR                            |

*** Memory (MEMEND)

The MEMEND ($CC2B) value in 6809 FLEX is not for total RAM, but for user RAM, and defaults to $BFFF, the maximum, so that user programs don't try to use RAM occupied by the operating system.  Refer to p.43 in the 6809 FLEX Adaptation Guide.

If you need to reduce this value in the FLEX.SYS file to reserve memory for drivers, it should be set to $BFFF - (n * $400), where n > 1, due to a bug in the FLEX memory check code at initialization (after jumping to $CD00).  Once FLEX is running, MEMEND can be set to any value less than $BFFF.

Until I figured this out by studying the source code for FLEX, trying to start FLEX on my ST-2900 with a changed value in MEMEND would hang up.  This bug in FLEX might not affect other systems the same way.

Dave W.

*** CMD Notes

CMD files contain load information
BIN files contain no load information (probably need the LOAD command)

I should have converted CLS.CMD to CLS.BIN, then run Dynamite
The CMD files contain 2 byte ORG, 2 Byte Length, Lenth Bytes,
next 2 Byte ORG, 2 Byte Length, ...

*** Editors

**** E

Pretty simple

**** Pie

Need details

**** PAT

I haven't gotten it running

**** SCREDIT

Don't know how to exit the edit mode

**** CED

This editor is annoying!

     SCREEN EDITOR (C) M.J.RANDALL 1985

                 OPTIONS

T--TOP            I--INPUT          Y--REPLACE WORD

B--BOTTOM         W--WRITE          C--COPY PART

P--REPLACEMENT    !--ERASE ALL      X--EXIT TO FLEX

M--SEARCH TARGET  V--VIEW TEXT      L--LOOK AT TABS

N--NEW TABS       R--REPEAT         S--START MACRO

E--END MACRO      U--PAGE UP        D--PAGE DOWN

tab-TO NEXT WORD

**** VED Screen Editor

https://github.com/nealcrook/multicomp6809/wiki/VED2-editor <- ANSI VED plus updates. Might not work with memulator

ved [-tn] [file]

VED is a screen oriented text editor written in C that was originally for use with the Aztec C65 system. The source to VED is included in the archive "VEDSRC.ARC". The source provided here has been ported to the 6809 FLEX system. It is compiled with the McCosh C compiler. VED is not a particularly fast or smart editor, but it does get the job done. If VED is invoked with a file name, that file will be loaded into the memory buffer, otherwise it will be empty. VED does all its editing in memory and is thus limited in the size of files that it will edit. In VED, the memory buffer is never completely empty. There will always be at least one newline in the buffer.

The "-t" option specifies that a different tab size should be used. Normally VED will use a value of four, but this may be overridden with this option, as in:

ved -t8 file.txt

which is useful since assembly language programs work well with a tab size of eight, but C works better with a tab size of four.

VED has a 1000 character limit on the size of a line. If a line is longer than the width of the screen, it will wrap to the next line. If a line starts at the bottom of the screen, and is too wide to fit, the line will not be displayed Instead, the '@' character will be displayed. Likewise, at the end of the file, all lines beyond the end will consist only of a single ,-, on each line.

A number of commands take a numeric prefix. This prefix is echoed on the status line as it is typed.

The normal mode of VED is command mode. During command mode, there are a number of ways to move the cursor around the screen and around the whole file.

newline     move to the beginning of the next line.
-           move to the start of the previous line.
space       move to the next character of the line.
backspace   move to the previous character.
0           move to the first character of this line.
$           move to the last character of this line.
h           move to the top line of the screen.
l           move to the bottom line of the screen.
b           move to the first line of the file.
g           move to the n'th line of the file.
/           string move to the next occurrence of 'string'.

When the cursor is in the appropriate spot, there are two commands used to delete existing text.

x    delete the n character under the cursor up to but not including the newline.
dd   delete n lines starting with the current line.

Note that deleting the last character on the line (newline character) causes the following line to be appended to the current line.

To add new text, hitting the 'i' key will cause the top line of the screen to indicate that you are now in <INSERT> mode. To exit insert mode, type ESCAPE (unless the CAPS LOCK mode is enabled, in which case type control Q). To insert a control character which means something special to VED into a text file, first type control-v followed by the control character itself. Control characters are displayed as '^X', where X is the appropriate character.

Typing 'o' will cause a new line to be created below the current line, and the cursor will be placed on that line and the editor placed into <INSERT> mode.

There are three commands used for moving text around. These commands make use of a 1000 character yank buffer. The contents of this buffer is retained across files.

yy    yank n lines starting with the current line into the yank buffer.
yd    yank n lines starting with the current line and then delete them.
p     "put" the lines in the yank buffer after the current line. The yank buffer is not modified.

The 'z' command redraws the screen with the current line in the center of the screen. The 'r'
command replaces the character under the cursor with the next character typed.

When in command mode, if the ':' key is hit, a ':' will be displayed on the status line. At this point, a number of special file-related commands may be given.

:f        displays info about the current file.
:w file	writes the buffer to the specified file name.
:w	writes the buffer to the last specified file.
:e file	clears the buffer and reads the named file.
:e! file	clears the buffer and reads the named file even if the file was modified
:r file	reads the named file into the buffer.
:q	exits the editor.
:q!	exits editor even if the file was modified

As can be seen VED protects from accidentally destroying the work being edited by preventing exiting or editing another file if the current file has been modified. If the file has been written using the ":w" command, the modified flag will be cleared.

VED will only edit text files. Binary files will not be edited.

**** EDIT

Edit is the default Flex editor. It's really a line editor but it's better
than edlin (yuck)

tedit

*** FuFu login

use http://www.flexusergroup.com:8080.

Userid: flexuser
Passwor: flex

*** Flex Notes Disk

Kees has suggested:
If one of you guys get the CPU09GPP+09FLP running, you can do trackdumps to help recover the data.
I have added that capability on the last year.

Under UniFLEX you allocate a buffer (12500 bytes or so)
open the character device  /dev/fdcx
seek(0,track,0)
with ttyset /dev/fdcx  you can preset:  data-rate, side and density
with a read buffer,12500  you get the track image
if you dump that, or examine it, the address and data marks are clearly identifiable and you
can copy your data out of it.

I could recover a few very old diskette contents that way.

================================================================================
Label: DSDD77-8
8" Disk with 77 tracks
DS
DD

Bytes/Sector = 256
Setors/Track = 10 (Nope) 0x34 (52 26/side)
Tracks/Side  = 77
Sides/Disk   = 2

256 * 10 * 77 * 2 = 394240 (unformatted )


ABASIC.IMA = 1019392

sector = 256 bytes
track = 256 * 10 = 2560 bytes (0x0A00)
track = 256 * 77 = 19712 each track 1-76 (4C)
track 0 = 7680b (1e00 )
Track 1 sector 1 starts at offset 7680 (starting from 0)

1019392 Feb  1 23:18 ABASIC.IMA

https://www.waveguide.se/?article=reading-flex-disk-images

FLEX disk layout

FLEX has a hard coded sector size of 256 bytes. Addressing sectors are done by track and sector numbers. Maximum number of tracks are 256 and maximum number of sectors per track are 256, which means a single FLEX file system can be up to 256^3 bytes which is about 16MB raw capacity. Not very big by todays standards but 30 years ago this was huge. The sectors are linked together like linked lists where the first two bytes of each sector is a pointer to the next sector in the chain (actually some sectors on track 00 are exceptions from this but for the rest of the disk this is true). The first two bytes of every directory sector and file data sector contains the track and address of the next sector in the chain. End of chain is marked by setting track and sector to zero. 

The sectors are linked together like linked lists where the first two bytes of each sector is a pointer to the next sector in the chain

A typical FLEX disk layout for a 40 track floppy with 20 sectors on each track:
TRACK 00 SECTOR 00 --- Boot sector
TRACK 00 SECTOR 01 --- Boot sector
TRACK 00 SECTOR 03 --- System Information Record (SIR)
TRACK 00 SECTOR 04 --- Not used
TRACK 00 SECTOR 05 --- Start of directory
 .
 .
TRACK 00 SECTOR 20 --- End of directory
TRACK 01 SECTOR 01 --- Start of file data
 .
 .
TRACK 39 SECTOR 20 --- End of file data (last sector on disk)

Tracks appears to be numbered from zero and up, and 
Sectors from one and up

The first important sector is the System Information Record (SIR).
The SIR contains basic information about the disk structure. 

SIR starts at track 0, sector 3
SIR structure is 16 bytes

typedef struct{
  u_byte volLabel[11];		//   11 byte --- Volume label
  u_byte volNumberHi;		//    2 byte --- Volume number
  u_byte volNumberLo;		//
  u_byte firstFreeTrack;	//    1 byte --- First free track
  u_byte firstFreeSector;	//    1 byte --- First free sector
  u_byte lastFreeTrack;		//    1 byte --- Last free track
  u_byte lastFreeSector;	//    1 byte --- Last free sector
  u_byte freeSectorsHi;		//    2 byte --- Number of free sectors
  u_byte freeSectorsLo;		//
  u_byte dateMonth;		//    1 byte --- Date month
  u_byte dateDay;		//    1 byte --- Date day
  u_byte dateYear;		//    1 byte --- Date year
  u_byte endTrack;		//    1 byte --- End track
  u_byte endSector;		//    1 byte --- End sector
} SIR_struct;

The SIR structure is 24 bytes long and starts at byte 17 of the SIR sector. The
first 16 bytes of the SIR sector is not used.

After the SIR follows the directory sectors.
The directory sectors are linked together to form one chain and the file data
sectors are linked together to form another chain. The length of the directory
can be varied and can span over multiple tracks if needed.

DIR starts at track 0, sector 5
DIR structure is 16 bytes

typedef struct{
  u_byte fileName[8];		//    8 byte --- File name                 0
  u_byte fileExt[3];		//    3 byte --- File extension            0a (09)
  u_byte unused1;		//    2 byte --- Not used                  
  u_byte unused2;
  u_byte startTrack;		//    1 byte --- Start track               0c (12)
  u_byte startSector;		//    1 byte --- Start sector
  u_byte endTrack;		//    1 byte --- End track
  u_byte endSector;		//    1 byte --- End sector
  u_byte totalSectorsHi;	//    2 byte --- Total number of sectors
  u_byte totalSectorsLo;
  u_byte randomFileFlag;	//    1 byte --- Random file flag
  u_byte unused3;		//    1 byte --- Not used
  u_byte dateMonth;		//    1 byte --- Date month
  u_byte dateDay;		//    1 byte --- Date day
  u_byte dateYear;		//    1 byte --- Date year
} DIR_struct;

   8 byte --- File name
   3 byte --- File extension
   2 byte --- Not used
   1 byte --- Start track
   1 byte --- Start sector
   1 byte --- End track
   1 byte --- End sector
   2 byte --- Total number of sectors
   1 byte --- Random file flag
   1 byte --- Not used
   1 byte --- Date month
   1 byte --- Date day
   1 byte --- Date year
 -----------------------
  24 byte --- Total

00000570  41 42 41 53 49 43 46 4c  43 4d 44 00 00 0e 23 0f  |ABASICFLCMD...#.|
00000580  0a 00 1c 00 00 04 0d 50  ff 4e 48 00 00 00 00 00  |.......P.NH.....|

0e 23 Start
0f 0a End
00 1c Size 28

Sector structure (?)

typedef struct{
  u_byte nextTrack;
  u_byte nextSector;
  u_byte SectorCntHi;
  u_byte SectorCntLo;

  data[252];
} Sector struct;

$ flextract  ABASIC.IMA  -l | less

Volume label     DSDD77-8UU
Volume number    1F40
Free area        t15 s13 - t15 s11
Free sectors     3213
End sector       t76 s52
Creation date    23-03-09

NAME           START     END        SIZE    DATE       FLAG
COPY.CMD       t01 s01 - t01 s05       5    81-03-09   00
DIR.CMD        t01 s06 - t01 s10       5    85-12-29   00
LIST.CMD       t01 s11 - t01 s13       3    80-01-30   00
ABASINT.CMD    t01 s14 - t01 s46      33    81-04-11   00
ABCOMPIL.CMD   t01 s47 - t02 s29      35    81-04-11   00
RTIO.TXT       t02 s30 - t02 s49      20    81-06-12   00
LD.CMD         t02 s50 - t03 s06       9    81-04-11   00
DSKIO.TXT      t03 s07 - t03 s25      19    81-06-12   00
CTIO.TXT       t03 s26 - t03 s39      14    81-06-12   00
ABASICRT.BIN   t03 s40 - t04 s15      28    80-02-25   00
ABASICRT.TXT   t04 s16 - t07 s25     166    23-08-20   00
ABASICSW.TXT   t07 s26 - t10 s39     170    80-04-04   00
ABASICSW.BIN   t10 s40 - t11 s15      28    80-04-05   00
ABASICFL.TXT   t11 s16 - t14 s34     175    80-04-13   00
ABASICFL.CMD   t14 s35 - t15 s10      28    80-04-13   00
INFO.TXT       t15 s12 - t15 s12       1    23-09-22   00

Total 739 sectors (?)
Ex
Tr 13 Sec 01-34 (this disk)

 -- Track 0 Sector 3 --
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 44 53 44 44 37 37 2D 38 ........DSDD77-8
44 53 44 44 37 37 2D 38 00 55 55 1F 40 0F 0D 0F DSDD77-8.UU.@...
00 55 55 1F 40 0F 0D 0F 0B 0C 8D 03 09 17 4C 34 .UU.@.........L4
0B 0C 8D 03 09 17 4C 34 00 00 00 00 00 00 00 00 ......L4........
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................

 -- Track 0 Sector 5 --                                             Tr Se
00 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ <- 00 06 (N sect 6)
00 00 00 00 00 00 00 00 43 4F 50 59 00 00 00 00 ........COPY....
43 4F 50 59 00 00 00 00 43 4D 44 00 00 01 01 01 COPY....CMD.....
43 4D 44 00 00 01 01 01 05 00 05 00 00 03 09 51 CMD............Q
05 00 05 00 00 03 09 51 44 49 52 00 00 00 00 00 .......QDIR.....
44 49 52 00 00 00 00 00 43 4D 44 00 00 01 06 01 DIR.....CMD.....
43 4D 44 00 00 01 06 01 0A 00 05 00 00 0C 1D 55 CMD............U
0A 00 05 00 00 0C 1D 55 4C 49 53 54 00 00 00 00 .......ULIST....
4C 49 53 54 00 00 00 00 43 4D 44 00 00 01 0B 01 LIST....CMD.....
43 4D 44 00 00 01 0B 01 0D 00 03 00 00 01 1E 50 CMD............P
0D 00 03 00 00 01 1E 50 41 42 41 53 49 4E 54 00 .......PABASINT.
41 42 41 53 49 4E 54 00 43 4D 44 00 00 01 0E 01 ABASINT.CMD.....
43 4D 44 00 00 01 0E 01 2E 00 21 00 00 04 0B 51 CMD.......!....Q
2E 00 21 00 00 04 0B 51 41 42 43 4F 4D 50 49 4C ..!....QABCOMPIL
41 42 43 4F 4D 50 49 4C 43 4D 44 00 00 01 2F 02 ABCOMPILCMD.../.
43 4D 44 00 00 01 2F 02 1D 00 23 00 00 04 0B 51 CMD.../...#....Q
 -- Track 0 Sector 6 --
00 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 41 42 41 53 49 43 52 54 ........ABASICRT
41 42 41 53 49 43 52 54 54 58 54 00 00 04 10 07 ABASICRTTXT.....
54 58 54 00 00 04 10 07 19 00 A6 00 00 08 14 17 TXT.............
19 00 A6 00 00 08 14 17 41 42 41 53 49 43 53 57 ........ABASICSW
41 42 41 53 49 43 53 57 54 58 54 00 00 07 1A 0A ABASICSWTXT.....
54 58 54 00 00 07 1A 0A 27 00 AA 00 00 04 04 50 TXT.....'......P
27 00 AA 00 00 04 04 50 41 42 41 53 49 43 53 57 '......PABASICSW
41 42 41 53 49 43 53 57 42 49 4E 00 00 0A 28 0B ABASICSWBIN...(.
42 49 4E 00 00 0A 28 0B 0F 00 1C 00 00 04 05 50 BIN...(........P
0F 00 1C 00 00 04 05 50 41 42 41 53 49 43 46 4C .......PABASICFL
41 42 41 53 49 43 46 4C 54 58 54 00 00 0B 10 0E ABASICFLTXT.....
54 58 54 00 00 0B 10 0E 22 00 AF 00 00 04 0D 50 TXT....."......P
22 00 AF 00 00 04 0D 50 41 42 41 53 49 43 46 4C "......PABASICFL
41 42 41 53 49 43 46 4C 43 4D 44 00 00 0E 23 0F ABASICFLCMD...#.
43 4D 44 00 00 0E 23 0F 0A 00 1C 00 00 04 0D 50 CMD...#........P

 -- Track 0 Sector 7 --
...
 -- Track 0 Sector 30 --
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................

00000000  86 f1 20 09 05 00 00 00  0f 1a 0c 00 00 1f 8b 32  |.. ............2|
00000010  8d 03 2d a6 8c ee 85 20  26 06 a6 8c ec a7 8c e8  |..-.... &.......|
00000020  86 02 97 02 30 8d 00 d8  17 00 6a 26 48 ec 8c d5  |....0.....j&H...|
00000030  10 27 00 dc 33 8d 02 c8  ef 8c d0 17 00 a3 81 02  |.'..3...........|
00000040  27 12 81 16 26 f5 17 00  98 a7 e3 17 00 93 a7 61  |'...&..........a|
00000050  4f 1f 8b 39 17 00 8a a7  e3 17 00 85 a7 61 35 20  |O..9.........a5 |
00000060  17 00 7e 27 d6 1f 89 34  04 17 00 75 a7 a0 35 04  |..~'...4...u..5.|
00000070  5a 26 f4 20 c6 30 8c 08  ad 9f f8 12 6e 9f f8 00  |Z&. .0......n...|
00000080  2d 20 43 61 6e 27 74 20  72 65 61 64 20 73 65 63  |- Can't read sec|
00000090  2e 32 0a 0a 04 86 8c 97  00 30 8d 01 63 20 04 96  |.2.......0..c ..|
000000a0  03 a7 80 96 08 2b f8 27  fa d6 00 c5 9c 39 d7 02  |.....+.'.....9..|
000000b0  e1 8d ff 54 34 01 e6 8d  ff 4a 35 01 23 02 ca 10  |...T4....J5.#...|
000000c0  d7 04 91 01 27 0a 97 03  86 1b 97 00 d6 08 27 fc  |....'.........'.|
000000d0  d6 00 c5 98 39 33 8d 01  27 ec c4 ed 8d ff 26 33  |....93..'.....&3|
000000e0  44 11 a3 8d ff 25 27 03  a6 c0 39 ec 8d ff 16 27  |D....%'...9....'|
000000f0  19 8d bb 17 ff 9f 27 dd  86 0b 97 00 8d ce 6a 8d  |......'.......j.|

00000100  ff 08 26 e7 30 8c 1e 16  ff 6e 30 8c 2e 16 ff 68  |..&.0....n0....h|
00000110  30 8c 03 16 ff 62 2d 20  4e 6f 74 20 4c 69 6e 6b  |0....b- Not Link|
00000120  65 64 0a 0a 04 2d 20 4e  75 63 6c 65 75 73 20 49  |ed...- Nucleus I|
00000130  2f 4f 20 45 72 72 6f 72  0a 0a 04 2d 20 42 61 64  |/O Error...- Bad|
00000140  20 4e 75 63 6c 65 75 73  0a 0a 04 00 00 00 00 00  | Nucleus........|
00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

00000200  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000210  44 53 44 44 37 37 2d 38  00 55 55 1f 40 0f 0d 0f  |DSDD77-8.UU.@...|
00000220  0b 0c 8d 03 09 17 4c 34  00 00 00 00 00 00 00 00  |......L4........|
00000230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000240  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000250  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000270  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000280  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000290  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

00000300  00 05 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................| < 5? (Next secoter is 00 05)
00000310  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000320  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000330  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000340  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000350  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000360  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000370  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000380  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000390  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

00000400  00 06 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................| <- 6? Need to look this up
00000410  43 4f 50 59 00 00 00 00  43 4d 44 00 00 01 01 01  |COPY....CMD.....|
00000420  05 00 05 00 00 03 09 51  44 49 52 00 00 00 00 00  |.......QDIR.....|
00000430  43 4d 44 00 00 01 06 01  0a 00 05 00 00 0c 1d 55  |CMD............U|
00000440  4c 49 53 54 00 00 00 00  43 4d 44 00 00 01 0b 01  |LIST....CMD.....|
00000450  0d 00 03 00 00 01 1e 50  41 42 41 53 49 4e 54 00  |.......PABASINT.|
00000460  43 4d 44 00 00 01 0e 01  2e 00 21 00 00 04 0b 51  |CMD.......!....Q|
00000470  41 42 43 4f 4d 50 49 4c  43 4d 44 00 00 01 2f 02  |ABCOMPILCMD.../.|
00000480  1d 00 23 00 00 04 0b 51  52 54 49 4f 00 00 00 00  |..#....QRTIO....|
00000490  54 58 54 00 00 02 1e 02  31 00 14 00 00 06 0c 51  |TXT.....1......Q|
000004a0  4c 44 00 00 00 00 00 00  43 4d 44 00 00 02 32 03  |LD......CMD...2.|
000004b0  06 00 09 00 00 04 0b 51  44 53 4b 49 4f 00 00 00  |.......QDSKIO...|
000004c0  54 58 54 00 00 03 07 03  19 00 13 00 00 06 0c 51  |TXT............Q|
000004d0  43 54 49 4f 00 00 00 00  54 58 54 00 00 03 1a 03  |CTIO....TXT.....|
000004e0  27 00 0e 00 00 06 0c 51  41 42 41 53 49 43 52 54  |'......QABASICRT|
000004f0  42 49 4e 00 00 03 28 04  0f 00 1c 00 00 02 19 50  |BIN...(........P|

00000500  00 07 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000510  41 42 41 53 49 43 52 54  54 58 54 00 00 04 10 07  |ABASICRTTXT.....|
00000520  19 00 a6 00 00 08 14 17  41 42 41 53 49 43 53 57  |........ABASICSW|
00000530  54 58 54 00 00 07 1a 0a  27 00 aa 00 00 04 04 50  |TXT.....'......P|
00000540  41 42 41 53 49 43 53 57  42 49 4e 00 00 0a 28 0b  |ABASICSWBIN...(.|
00000550  0f 00 1c 00 00 04 05 50  41 42 41 53 49 43 46 4c  |.......PABASICFL|
00000560  54 58 54 00 00 0b 10 0e  22 00 af 00 00 04 0d 50  |TXT....."......P|
00000570  41 42 41 53 49 43 46 4c  43 4d 44 00 00 0e 23 0f  |ABASICFLCMD...#.|
00000580  0a 00 1c 00 00 04 0d 50  ff 4e 48 00 00 00 00 00  |.......P.NH.....|
00000590  42 41 4b 00 00 0f 0b 0f  0b 00 01 00 00 04 0b 51  |BAK............Q|
000005a0  49 4e 46 4f 00 00 00 00  54 58 54 00 00 0f 0c 0f  |INFO....TXT.....|
000005b0  0c 00 01 00 00 09 16 17  00 00 00 00 00 00 00 00  |................|
000005c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000005d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000005e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000005f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

https://github.com/keirf/FlashFloppy/issues/378

keirf commented on Oct 6, 2020 • 
The FLEX formatted HFE has 10*256b sectors per track, cylinder 0, FM recording. Sectors are numbered 1-20 (across both sides) and have interleave 4:1, and that extends across to side 1 (sector id 11 is the second sector on side 1).

Cylinders > 0: 18*256b sectors per track, MFM recording. Sectors are numbered 1-36 (across both sides) and have interleave 6:1, and that extends across to side 1 (sector id 19 is the sixth sector on side 1).

The DSK looks to be all MFM, as it is 737,280 bytes. I would expect a DSK with FM track0 to be 733,184 bytes. Also interesting to note that some FLEX docs mention that track0 has no sector1 and has a sector0 instead. That isn't the case in the HFE image here! Perhaps there is variation in FLEX disk format across different systems running FLEX?

@mikewbrantley
Author
mikewbrantley commented on Oct 6, 2020
The physical disk that is formatted with Flex has Track 0 starting with sector 1 and goes through sector 10 on side one. Side two starts with sector 11 and goes through sector 20. This is FM recording. Tracks 1 through 79 are recorded with MFM and has 18 sectors per side.

I will get in touch with Mike Evenson and ask about the dsk file formatting he does with the emulator tool. Now that I think about it, the only time I ever use this tool is to build a dsk file for storage and to extract files from it. The flashfloppy emulator is the first time I have ever tried extracting these files from anything other than Mike's utility. I'm sorry for making this so confusing by expecting the emulator tool to perform just as the Flex formatter.

@keirf
Owner
keirf commented on Oct 6, 2020
Here is another DSK sent by @mikewbrantley. This one is formatted with FM track 0. Note that it is still 720k. Cylinder 0 is padded out to 36*256-byte size by 16 unused sectors (file offsets 0x1400-0x2400). Note that the space allocation and padding seems to be done per cylinder, not per track. ie. the DSK file logically comprises 80 9kB cylinders, rather than 160 4.5kB tracks.

This ought to be somehow made configurable in IMG.CFG...

BB184.zip (in Downloads: disk image not needed)

Michael Evenson developed a program to create a dsk image with 10 sectors per side on track 0 and 18 per side on tracks 1 through 79. I am attaching the file I created using this software. Does it look correct now?

https://deramp.com/swtpc.com/FLEX20/Flex20_Index.htm

*** SWTPC 1.3A PT68-1

TABLE           FCC     'G'              GOTO
                FDB     GOTO
                FCC     'Z'              GOTO PROM
                FDB     PROM
                FCC     'M'              MEMORY EXAMINE AND CHANGE
                FDB     CHANGE
                FCC     'F'              BYTE SEARCH
                FDB     SEARCH
                FCC     'R'              REGISTER DUMP
                FDB     PRINT
                FCC     'J'              jump
                FDB     JUMP
                FCC     'C'              CLEAR SCREEN
                FDB     CLEAR
                FCC     'D'              DISK BOOT sector 0
                FDB     FDISK
                FCC     'U'              DISK BOOT sector 1
                FDB     GDISK
                FCC     'W'              SD CARD BOOT
                FDB     WBOOT
                FCC     'B'              BREAKPOINT
                FDB     BREAK
                FCC     'O'              OPTIONAL PORT
                FDB     OPTL
TABLE1          FCC     'P'              ASCII PUNCH
                FDB     PUNCH1
                FCC     'L'              ASCII LOAD
                FDB     LOAD
                FCC     'E'              END OF TAPE
                FDB     PNCHS9
                FCC     '0'
                FDB     OPTNL
                FCC     'Q'              MEMORY TEST
                FDB     MEMTST
                FCC     'H'              RETURN TO FLEX
                FDB     WARMS            FLEX WARM START ENTRY
                FCC     'I'
                FDB     MEMINIT

.* THESE ARE ADDED FOR THE DISASSEMBLER AND DEBUGGER 

                FCB     #$54             "T"
                FDB     TRACE            SMITHBUG DEBUGGER
TABEND          FCB     #$41             "A"
                FDB     DISSA

** 68Retro MP-02 & MP-IO Notes 

*** 68Retro MP-02 BOM

68retro MP-02 6802 Processor Board Rev. 3
Bill of Material

|-----+-------------------+-------------------------------------------------------|
| Qty | Designator        | Description                                           |
|-----+-------------------+-------------------------------------------------------|
|   4 | R1,R2,R3,R4,R5    | 3k3 1/4W 5% Resistor                                  |
|   3 | RN1,RN2,RN3       | Resistor Network 9 Pin, 8 Common 100k                 |
|   1 | C1                | 1uF RB 16vW Electrolytic Capacitors 0.1” spacing      |
|   . | .                 | Reset Capacitor (Use without IC1, using .1uF)         |
|   1 |                   | 10nF 50V Ceramic Capacitor (if IC1 installed)         |
|   2 | C2,C3             | 33pF 100V Ceramic capacitor 0.2” spacing              |
|  10 | C4,C5,C6,         | .                                                     |
|   . | C7,C9,C10,        | .                                                     |
|   . | C11,C12,C13,C14   | 100nF 50V Monolithic capacitors 0.2” spacing          |
|   1 | C8                | 10uF RB 16vW Electrolytic Capacitors 0.1” spacing     |
|   4 | IC2,IC4,IC5,IC7   | 14 pin Dual Wipe IC socket (optional)                 |
|   1 | IC6               | 16 pin Dual Wipe IC socket (optional)                 |
|   1 | IC8               | 20 pin Dual Wipe IC socket (optional)                 |
|   1 | IC9               | 28 pin Dual Wipe IC socket (optional)                 |
|   1 | IC10              | 32 pin Dual Wipe IC socket (optional)                 |
|   1 | IC3               | 40 pin Dual Wipe IC socket (optional)                 |
|   5 | CN1               | 10 Way Molex KK 4455 Series Tin (22-15-2106)          |
|   6 | J2,J3,J4,J5,J6,J7 | 3 Pin 0.1” spacing pin headers.                       |
|   1 | ‘RE’              | 2 Pin 0.1” spacing pin header.                        |
|   1 | IC1               | DS1233-5 TO-92 (optional)                             |
|   2 | IC2,IC5           | 74HC30 8-Input NAND 14 Pin DIP                        |
|   1 | IC3               | MC6802P Microprocessor 40 Pin DIP                     |
|   1 | IC4               | 74HC04 Hex Inverter 14 Pin DIP                        |
|   1 | IC6               | 74HC138 3 to 8 Line Decoder 16 Pin DIP                |
|   1 | IC7               | 74HC00 Quad NAND Gate 14 Pin DIP                      |
|   1 | IC8               | 74HC688 8-bit Magnitude Comparator 20 Pin DIP         |
|   1 | IC9               | EPROM,EEPROM 2k to 64k (x8) 28 pin socket.            |
|   1 | IC10              | SRAM 2k to 512k (x8) 32 pin socket.                   |
|   1 | X1                | 4MHz Crystal HC49                                     |
|   1 | SW1               | ‘Reset’ Omron 6mm x 6mm B3F-1nnn or equivalent        |
|   3 | SW2,SW3,SW4       | 8 position DIP Switch                                 |
|   7 | 2                 | Pin Shunts 0.1”                                       |
|   1 | PCB               | 68retro MP-02 Rev. 3                                  |
|-----+-------------------+-------------------------------------------------------|

*** 68Retro MP-IO BOM

68retro MP-IO PIA/ACIA I/O Board Rev. 1
Bill of Material

|-----+----------------+---------------------------------------------------|
| Qty | Designator     | Description                                       |
|-----+----------------+---------------------------------------------------|
|   1 | R1             | 10M 1/4W 5%                                       |
|   1 | R2             | 330R 1/4W 5% (Above LED D2)                       |
|   2 | R3,R4          | 2k7 1/4W 5%  (RXA,TXA)                            |
|   2 | R5,R6          | 100k 1/4W 5% (CTSA, DCDA)                         |
|   1 | R7             | 470R 1/4W 5%                                      |
|   1 | IC1            | 40 pin Dual Wipe IC socket (optional)             |
|   2 | IC2,IC3        | 16 pin Dual Wipe IC socket (optional)             |
|   1 | IC4            | 24 pin Dual Wipe IC socket (optional)             |
|   5 | C1,C3,C4,C7,C9 | 100nF 50V Monolithic capacitors 0.2” spacing      |
|   2 | C5,C6          | 22pF 100V Ceramic capacitor 0.2” spacing          |
|   3 | C2,C8,C10      | 10uF RB 16vW Electrolytic Capacitors 0.1” spacing |
|   1 | CN1            | 24 way Straight 0.1” pin header.                  |
|   1 | CN2            | 26 way (2x13) 0.1” straight box header.           |
|   1 | CN3            | 50 Way (1x50) 0.1” spacing pin header             |
|   . | .              | (see text for card edge connector details)        |
|   1 | CN4            | 6 Way (1x6) R/A 0.1” spacing pin header.          |
|   8 | .              | ‘A’, ’B’, ’C’, ’PA’, ’PB’, ’RS0’,‘RS1’,’PWR SEL’  |
|   3 | .              | Pin 0.1” spacing pin headers.                     |
|   1 | J3             | 24 way (3x8) 0.1” spacing pin header.             |
|   1 | J12            | (2x9) 18 pin 0.1” spacing pin header.             |
|   1 | IC1            | MC6821 PIA 40 Pin DIP                             |
|   1 | IC2            | 74HC138 3 to 8 Line Decoder 16 Pin DIP            |
|   1 | IC3            | 74HC4060 14 Stage Binary Counter 16 pin DIP       |
|   1 | IC4            | MC6850 ACIA 24 Pin DIP                            |
|   1 | D2             | LED 3mm RED                                       |
|   1 | X1             | 2M4576Hz Crystal HC49                             |
|   1 | CN5            | Barrel Jack OD 5.5 / ID 2.1                       |
|  11 | .              | 2 Pin Shunts 0.1”                                 |
|   1 | PCB            | 68retro MP-IO Rev. 1                              |
|-----+----------------+---------------------------------------------------|

*** 68Retro MP-02 & MP-IO BOM

|-----+----------+----------------------------------------+--------------------+-----+---|
| Qty | Desc     | Notes                                  | Order              |   n |   |
|-----+----------+----------------------------------------+--------------------+-----+---|
|   4 | 14       | Sockets Pitch: 2.54 mm, 0.3            | 1-2199298-3        |  12 | x |
|   3 | 16       |                                        | 1-2199298-4        |   9 | x |
|   1 | 20       |                                        | 1-2199298-6        |   2 | x |
|   2 | 24       | Pitch: 2.54 mm, 0.6 (.3 cut it)        | 1-2199298-8        |   6 | x |
|   1 | 28       |                                        | 1-2199299-2        |   3 | x |
|   1 | 32       |                                        | 1-2199300-2        |   3 | x |
|   2 | 40       | Pitch: 2.54 mm, 0.6                   |  1-2199299-5        |   6 | x |
|   5 | 3k3      | 1/4W 5%                                | -                  |  15 | x |
|   1 | 10M      |                                        | -                  |   3 | x |
|   1 | 330R     |                                        | -                  |   3 | x |
|   2 | 2K7      |                                        | -                  |   6 | x |
|   1 | 100k     |                                        | -                  |   3 | x |
|   1 | 470R     |                                        | -                  |   3 | x |
|   3 | 100k     | 9pin R Net                             | 4609X-101-104LF    |   9 | x |
|   1 | 10nF     | 50V Ceramic (Dallas 1233, sub smt)     | GRT0335C1HR10WA02D |   3 | x |
|   2 | 33pF     | 100V Ceramic 0.2" spacing              | AR215A330K4RTR1    |   6 | x |
|   2 | 22pf     |                                        | SR215A220JARTR1    |   6 | x |
|  14 | 100nf    | 50V Mono cap 0.2" spacing              | AR205C103K4R       | 100 | x |
|   1 | 1uF      | 16v Electrolytic 0.1” -ignore-         | -                  |   3 | - |
|   4 | 10uF     | 16v Electrolytic 0.1"                  | ECA-1CM100I        |  12 | x |
|   5 | CN1      | F 10 Way Molex KK 254 (22-15-2106)     | 22-15-2106         |  15 | x |
|   5 | CN       | M 10 Way Molex KK 254 (22-23-2101 ?)   | 22-23-2101         |  15 | x |
|   6 | JP       | 3pin 0.1" header                       | 67996-150HLF       |  10 | x |
|   1 | JP       | 2pin 0.1" header                       | 77313-118-50LF     |  10 | x |
|   1 | DS1233-5 |                                        | DS1233-5+          |   3 | x |
|   2 | 74HC30   |                                        | CD74HC30M96        |   6 | x |
|   1 | 74HC04   |                                        | SN74HC04AN         |   3 | x |
|   2 | 74HC138  |                                        | SN74HC138N         |   6 | x |
|   1 | 74HC00   |                                        | SN74HC00N          |   3 | x |
|   1 | 74HC688  |                                        | SN74HC688N         |   3 | x |
|   1 | 74HC4060 |                                        | SN74HC4060N        |   3 | x |
|   1 | HC49     | 2M4576Hz Crystal HC49                  | MP024S             |   3 | x |
|   1 | HC49     | 4MHz xtal                              | XT9S20ANA4M        |   3 | x |
|   1 | PB       | Omron 6mm x 6mm B3F-1nnn or equivalent | B3FS-1050P         |   3 | x |
|     |          |                                        | COM-00097          |   3 |   |
|   3 | DPSW     | 8pos dip switch                        | DS01C-254-S-08BE   |   9 | x |
|   7 | shunt    | 0.1" shunts                            | M7583-46           |  50 | x |
|   1 |          | Barrel Jack 5.5/2.1                    | PRT-00119          |   3 | x |
|   1 | ROM      | 256Kx8 150ns dip                       | AT28C256-15PU      |   3 | x |
|     |          |                                        | DEV-15583          |   1 |   |
|-----+----------+----------------------------------------+--------------------+-----+---|

*** Molex part #s

Rt Angle Male
https://www.molex.com/en-us/products/part-detail/22053101
KK 254 Solid Header, Right-Angle, with Friction Lock, 10 Circuits, Tin (Sn) Plating
Part Number: 22053101
Series Number: 7478

Rt Angle Female
https://www.molex.com/en-us/products/part-detail/22152106
KK 254 PC Board Connector, Right-Angle, End-to-End Stackable, 2.54µm Tin (Sn), 10 Circuits
Part Number: 22152106
Series Number: 4455

Straight Male
https://www.molex.com/en-us/products/part-detail/22032101
KK 254 Wire-to-Board Header, Single Row, Vertical, 10 Circuits, PA Polyamide Nylon, Tin (Sn) Plating
Part Number: 22032101
Series Number: 4030

Straight Female
https://www.molex.com/en-us/products/part-detail/22027103
KK 254 PC Board Connector, Top Entry, with Cat Ear Terminal, 2.54µm Tin (Sn), 10 Circuits, without Hooks
Part Number: 22027103
Series Number: 4455

** 68Retro 68008 SS50C bus

MP-A8 - SWTPC 68008 CPU board.

The MP-A8 will have a full 1M of SRAM, xK of ROM and plug into the SS50 bus which will be mapped into one of the 16 - 64K segments of RAM.

*** Design notes

- Running the 68008
  - Use the 1M on the SS50 bus (but build a local int for testing).
  - Not sure what to do with the baud rate generator part. Will need to resolve.
- 1M of RAM (kinda)
  - ROM drops into $0.0000 on reset
  - RAM drops into $0.0000 after reset (need that circuit).
  - ROM overlaps RAM @$F.0000 (can be banked in by writing to ???)
  - 
- Need 64K segments for Flex, where to put it? - *Not* needed with SS50 extended bus.
  - there are 16 segments of 64K
    - 74LS154 - 4 to 16
    - 
  - Minimum system?
    - SS50/SS3 bus
      - MP-S @$x.8000?
- 64K ROM?
- 64K dedicated to the SS50 bus @$0.0000 if extended bus
  - IO in that bus range
  - 6850/VGA board console (serial or VGA & Keyboard)
    - would like to see the PIC32 support USB keyboards
  - MP Serial - Console
  - MP Parallel
  - IDE
- 1M - 16x64k (use the SS50 1M card)


- 74LS244 Addr driver
- 74LS245 Data driver

*** Map

**** 68K

RAM board is the 1MB RAM board on the SS50
No memory on the MP-A8.

|-----+-----+-----+-----+--------+--------+---------+----------------------------|
| A19 | A18 | A17 | A16 |   From | to     | Desc    | Notes                      |
|-----+-----+-----+-----+--------+--------+---------+----------------------------|
|   0 |   0 |   0 |   0 | 0.0000 | 0.0FFF | Vectors |                            |
|   0 |   0 |   0 |   1 | 0.1000 | 0.FFFF |         | Flex IO lives here         |
|   0 |   0 |   1 |   0 | 2.0000 |        |         |                            |
|   0 |   0 |   1 |   1 | 3.0000 |        |         |                            |
|   0 |   1 |   0 |   0 | 4.0000 |        |         |                            |
|   0 |   1 |   0 |   1 | 5.0000 |        |         |                            |
|   0 |   1 |   1 |   0 | 6.0000 |        |         |                            |
|   0 |   1 |   1 |   1 | 7.0000 |        |         |                            |
|   1 |   0 |   0 |   0 | 8.0000 |        |         |                            |
|   1 |   0 |   0 |   1 | 9.0000 |        |         |                            |
|   1 |   0 |   1 |   0 | A.0000 |        |         |                            |
|   1 |   0 |   1 |   1 | B.0000 |        |         |                            |
|   1 |   1 |   0 |   0 | C.0000 |        |         |                            |
|   1 |   1 |   0 |   1 | D.0000 |        |         |                            |
|   1 |   1 |   1 |   0 | E.0000 |        |         |                            |
|   1 |   1 |   1 |   1 | F.0000 | F.FFFF | ROM     | ROM must be on board MP-A8 |
|-----+-----+-----+-----+--------+--------+---------+----------------------------|

**** 6800/Flex 2 memory usage:

|------+------+------------------------------------------------------|
| From | To   | ADDRESS DESCRIPTION                                  |
|------+------+------------------------------------------------------|
| 0000 | 7FFF | User RAM (Some of the lower end of this area is used |
|      |      | by certain utilities such as NEWDISK.)               |
| A000 | A07F | Stack Area (SP is initialized to A07F)               |
| A080 | A0FF | Input Buffer                                         |
| A100 | A6FF | Utility Command Area                                 |
| A700 | A83F | Scheduler & Printer Spooler                          |
| A840 | A97F | System FCB                                           |
| A980 | ABFF | System Files Area                                    |
| AC00 | B3FF | DOS                                                  |
| B400 | BE7F | FMS                                                  |
| BE80 | BFFF | Disk Drivers                                         |
|------+------+------------------------------------------------------|

**** 6809/Flex 2 memory usage:

(WIP)
|------+------+------------------------------------------------------|
| From | To   | ADDRESS DESCRIPTION                                  |
|------+------+------------------------------------------------------|
| 0000 | 7FFF | User RAM (Some of the lower end of this area is used |
|      |      | by certain utilities such as NEWDISK.)               |
| A000 | A07F | Stack Area (SP is initialized to A07F)               |
| A080 | A0FF | Input Buffer                                         |
| A100 | A6FF | Utility Command Area                                 |
| A700 | A83F | Scheduler & Printer Spooler                          |
| A840 | A97F | System FCB                                           |
| A980 | ABFF | System Files Area                                    |
| AC00 | B3FF | DOS                                                  |
| B400 | BE7F | FMS                                                  |
| BE80 | BFFF | Disk Drivers                                         |
|------+------+------------------------------------------------------|

*** Links

https://daveho.github.io/2016/07/14/mc68008-blinkenlights.html
[[https://wandel.ca/homepage/mc68008/index.html][A Small MC68008 Computer System]] <- Good ref for basic designs
https://github.com/daveho/ya68k2
https://gunkies.org/wiki/SS-50_bus

*** References

- Barth, Andrew J., 1984. Designing with the 68008 Microprocessor. Motorola article reprint AR226.
- Brown, Geoffrey and Harper, Kyle, 1984. MC68008 Minimum Configuration System. Motorola application note AN897.
- Harper, Kyle, 1984. A Terminal Interface, Printer Interface, and Background Printing for an MC68000 based System using the MC68681 DUART. Motorola application note AN899.
- Motorola, Inc., 1981. MC68000 Educational Computer Board. Motorola publication MEX68KECB.
- Motorola, Inc., 1988. M68000 Family Reference Motorola publication FR68K/D.
- Motorola, Inc., 1989. MC68000, MC68008, MC68010, MC68HC000 8-/16-/32-Bit Microprocessor User's Manual, 6th Edition. Motorola publication M68000UM/AD Rev 5.

*** RAM/ROM mapping at startup

When the MC68008 initializes, it starts fetching instructions at memory address 0. For this reason, it is necessary to have some form of ROM (such as an EPROM) mapped at address 0, so that the firmware can take control.

In theory we could just leave ROM mapped at address 0 permanently. Unfortunately, the CPU’s interrupt vector table is located at address 0. If we want to allow interrupts to be handled in a reasonable way as the system runs, we need to have RAM mapped at address 0. So, we need a way to have ROM mapped at address 0 on startup, but RAM mapped during normal operation.

My solution is to use a 74HCT393 counter chip. This chip is two 4-bit counters which increment on a low-to-high clock transition. If we cascade the two 4-bit counters, we get an 8-bit counter. The counter is reset (cleared) by the reset signal generated by the MAX1232, and when the reset pulse ends the counter is incremented by low-to-high clock transitions. The most significant bit of the 8-bit counter effectively divides the system clock by 256. This signal will be low for the first 128 clock cycles following reset, high for the next 128 clock cycles, etc.

The system’s glue logic can use this signal to map the firmware EPROM at address 0 during the first 128 cycles, and then map the static RAM at address 0 subsequently. This gives the firmware a chance to jump from a low code address to a permanent code address. (I plan to map the EPROM in the high 64K of the address space.) On the schematic, I am calling this signal CLKDIV256.

As an additional use for this signal, I am feeding it to the -ST pin of the MAX1232. This ensures that a watchdog reset will not occur (as mentioned above).

*** Parts

|-----+-------+-----------------+-------+---------------+---|
| Qty |  Desc | Notes           | Order | n             |   |
|-----+-------+-----------------+-------+---------------+---|
|   1 | 68008 | CPU What speed? |       | 8,10 or 12    | x |
|   2 |       | 512Kx8 RAM      |       |               |   |
|   1 |       | EPROM           |       | 27128 min (?) |   |
|   1 |       | 68B50           |       | SS30          |   |
|     |       | VGA/Keyboard    |       |               |   |
|     |       | IDE             |       |               |   |
|     |       | 64K I/O         |       |               |   |
|     |       | Floppy          |       |               |   |
|     |       | Parallel        |       |               |   |
|     |       | Network         |       | Fujinet?      |   |
|-----+-------+-----------------+-------+---------------+---|

*** Addressing

74LS154 4 of 16 decoder

A16,A17,A18,A19

|-------+-------+-----+---+---|
| Start | End   | Out |   |   |
|-------+-------+-----+---+---|
| 00000 | 01000 |   0 |   |   |
| 00000 | 0FFFF |   0 |   |   |
| 10000 |       |   1 |   |   |
| 20000 |       |   2 |   |   |
| 30000 |       |   3 |   |   |
| 40000 |       |   4 |   |   |
| 50000 |       |   5 |   |   |
| 60000 |       |   6 |   |   |
| 70000 |       |   7 |   |   |
| 80000 |       |   8 |   |   |
| 90000 | 9FFFF |   9 |   |   |
| A0000 |       |  10 |   |   |
| B0000 |       |  11 |   |   |
| C0000 |       |  12 |   |   |
| D0000 |       |  13 |   |   |
| E0000 |       |  14 |   |   |
| F0000 | FFFFF |  15 |   |   |
|-------+-------+-----+---+---|

*** DTACK

- Grounded (a cheat)

*** 68KBUG

Need a simple bug for the MP-A8, something akin to MIKBUG.

| D | Dump hex            |                                                  |
| G | Go to user code     |                                                  |
| J | JSR to address      |                                                  |
| L | LOAD S1/S3 (?) Dump |                                                  |
| M | Memory Change       |                                                  |
| P | Punch S1/S2/S3      | https://en.wikipedia.org/wiki/SREC_(file_format) |
| R | Display registers   |                                                  |

*** SS50

- Need to map controls and IRQs into the SS50.

|-------+------------+---------+----------+-------|
|  Line | Function   |         |          | Notes |
|-------+------------+---------+----------+-------|
| SS-50 | SS-50      | SS-50C  | S/09     |       |
|-------+------------+---------+----------+-------|
|     1 | D0         | D0      | D0       |       |
|     2 | D1         | D1      | D1       |       |
|     3 | D2         | D2      | D2       |       |
|     4 | D3         | D3      | D3       |       |
|     5 | D4         | D4      | D4       |       |
|     6 | D5         | D5      | D5       |       |
|     7 | D6         | D6      | D6       |       |
|     8 | D7         | D7      | D7       |       |
|     9 | A15        | A15     | A15      |       |
|    10 | A14        | A14     | A14      |       |
|    11 | A13        | A13     | A13      |       |
|    12 | A12        | A12     | A12      |       |
|    13 | A11        | A11     | A11      |       |
|    14 | A10        | A10     | A10      |       |
|    15 | A9         | A9      | A9       |       |
|    16 | A8         | A8      | A8       |       |
|    17 | A7         | A7      | A7       |       |
|    18 | A6         | A6      | A6       |       |
|    19 | A5         | A5      | A5       |       |
|    20 | A4         | A4      | A4       |       |
|    21 | A3         | A3      | A3       |       |
|    22 | A2         | A2      | A2       |       |
|    23 | A1         | A1      | A1       |       |
|    24 | A0         | A0      | A0       |       |
|    25 | GND        | GND     | GND      |       |
|    26 | GND        | GND     | GND      |       |
|    27 | GND        | GND     | GND      |       |
|    28 | +8V        | +8V     | +8V      |       |
|    29 | +8V        | +8V     | +8V      |       |
|    30 | +8V        | +8V     | +8V      |       |
|    31 | -12V       | -12V    | -12V     |       |
|    32 | +12V       | +12V    | +12V     |       |
|    33 | INDEX      | INDEX   | INDEX    |       |
|    34 | MRDY       | M RESET | MRDY     |       |
|    35 | BUSY       | NMI     | NMI/BUSY |       |
|    36 | IRQ        | IRQ     | IRQ      |       |
|    37 | FIRQ       | UD2     | FIRQ     |       |
|    38 | Q          | UD1     | Q        |       |
|    39 | E          | φ2      | E        |       |
|    40 | VMA        | VMA     | VMA      |       |
|    41 | R/W        | R/W     | R/W      |       |
|    42 | Reset      | Reset   | Reset    |       |
|    43 | BA         | BA      | BA       |       |
|    44 | BS         | φ1      | BS       |       |
|    45 | HALT       | HALT    | HALT     |       |
|    46 | 110b/BREQ  | 110b    | BREQ     |       |
|    47 | 150b/9600b | 150b    | A19      |       |
|    48 | 300b       | 300b    | A18      |       |
|    49 | 600b/4800b | 600b    | A17      |       |
|    50 | 1200b      | 1200b   | A16      |       |
|-------+------------+---------+----------+-------|

Notes:

- Verification is still needed for some of these signals!
- D0 - D7: Data Bus: The SS-50 data bus is the complement of the CPU data bus lines D0-D7. These lines are bidirectional.
- R/W: Read/Write: The read/write line of the processor. When it is high, D0-D7 are inputs to the CPU, when low D0-D7 are outputs from the CPU.
- A0-A15: Address bus: Address bus of the CPU.
- A16-A20: Address bus extension (S/09 only): Used by bank switching or paged memory systems to address up to 1MB of memory
- VMA: Valid Memory Address: The complemented 6800/6809 VMA line. Goes low when a valid address has been placed on the address bus.
- M RESET: Manual Reset: This pin is the input to a one-shot multivibrator. When pulled low by e.g. pressing a reset button, the one-shot pulses the Reset line which resets the system
- Reset: The reset line is the output of the one-shot triggered either by M RESET or automatically on system power up. It is connected to the reset input of the processor, and to other resettable pheripherals.
- NMI: Non-maskable interrupt: Active low line connected to the processor's NMI input.
- IRQ: Interrupt Request: Active low line connected to the processor's IRQ input.
- HALT: Halt: Active low line connected to the processor's HALT input. The 6800 halts the execution and floats the address and data buses and the R/W line. External devices can then access memory for DMA, for example
- BA: Bus Available: This is the BA output of the processor. Goes high in response to a Halt input, to signal that buses are available (floating)
- BS: Bus Status: This is the BS output of the 6809 processor. Goes high with BA on e.g. BREQ (-C and -S/09 only)
- φ1: The Phase 1 output from the two-phase non-overlapping clock of the processor
- φ2: The inverted Phase 2 output from the two-phase non-overlapping clock of the processor, used to indicate the presence of valid data on the data bus
- UD1, UD2: User Defined: User defined lines are not assigned pre-defined functions.
  - 110b,150b,300b,600b,1200b: Serial clock: Outputs of a crystal-controlled baud rate generator, may be used by a serial line interface peripheral 4800b,9600b: Serial clock: (-C only)
- GND: Ground lines
- +8V: Power: Unregulated +8V (labelled as '7-8 VDC UNREGULATED' on SWTPC 6800 motherboard), may be used by on-board regulators to create +5V, for example
- -12V: Power: Regulated -12V
- +12V: Power: Regulated +12V
- INDEX: No pin: Physically plugged to prevent incorrect insertion of a board
- MRDY: Memory Ready (6809 only): When low, E and Q may be stretched in intervals of 1/4 bus cycles (-C and -S/09)
- BUSY: Busy (-C and -S/09 only)
- FIRQ: Fast Interrupt Request: Active low line connected to the 6809's FIRQ input (-C and -S/09)
- BREQ: Bus Request: Active low line connected to the 6809's DMA/BREQ input(-C and -S/09 only)
- Q: Quadrature Clock Signal (6809 only) (-C and -S/09)
- E: Clock Signal similar to the 6800 φ2 (6809 only) (-C and -S/09>

The table entries with two options, e.g. 110b/BREQ are configurable with switches on the motherboard.

*** SS30

L->R component side of the board

|-------+----------+------+-----+---------------|
|  Line | Function |      |     | Notes         |
|-------+----------+------+-----+---------------|
| SS-30 | SS-30    |      |     |               |
|-------+----------+------+-----+---------------|
|     1 | Select   |      |     | Slot select   |
|     2 | Reset    |      |     |               |
|     3 | 110      | BREQ |     |               |
|     4 | 9600     |      |     | 150/9600      |
|     5 | 300      |      |     |               |
|     6 | 4800     |      |     | 500/4800      |
|     7 | 1200     |      |     |               |
|     8 | +8v      |      |     |               |
|     9 | +8v      |      |     |               |
|    10 | R/W      |      |     |               |
|    11 | E        |      |     |               |
|    12 | D7       |      |     |               |
|    13 | D6       |      |     |               |
|    14 | D5       |      |     |               |
|    15 | D4       |      |     |               |
|    16 | D3       |      |     |               |
|    17 | D2       |      |     |               |
|    18 | D1       |      |     |               |
|    19 | D0       |      |     |               |
|    20 | RS1      |      |     |               |
|    21 | RS0      |      |     |               |
|    22 | IRQ      |      |     |               |
|    23 | FIRQ     |      |     |               |
|    24 | Index    |      |     |               |
|    25 | GND      | GND  | GND |               |
|    26 | GND      | GND  | GND |               |
|    27 | +16v     |      |     |               |
|    28 | +16v     |      |     |               |
|    29 | RS3      |      |     |               |
|    30 | RS2      |      |     |               |
|-------+----------+------+-----+---------------|


** RT68mx Notes

Seems that flextract has a few issues (and isn't nice code either). It can't handle more than 34 tracks and Kees' ABASIC.IMA disk is DSDD77-8 (8" 77 tracks)

*** ABASIC.IMA vs ABASICSR.DSK notes

#+begin_src ASCII
> No this is Kee's ABASIC.IMA in his ABASIC.zip. This file is in his
> Sept email with the zip as attachment.  

Hi Neil,
your previous email said "The ABASIC.DSK disk is partially readable..."
hence my confusion. I used FloppyMaintenance 4.0.2.11789 under WINE to
successfully export the files from Kee's ABASIC.IMA. In the
ABCOMPIL.CMD file I found a "7EAD03" so its a 6800 FLEX version. The
copyright string is "MICROWARE A/BASIC COMPILER V2.1F". ABASINT.CMD
also looks to be 6800 FLEX, there is no obvious copyright message.
ABASICFL.CMD contains the string "A/BASIC V3.0".

The ABASIC.DSK in Kee's file is the same as the FHL one I referenced
before and contains this copyright message "ABASIC  (c) 1982  Harry B.
Fair". In the code of the file "ABASIC.CMD" I found "BDD406" and
"7ECD03" so it is 6809 FLEX.

Kee's ABASIC_1.DSK contains the same directory as the one in the FHL
ABASIC_1.DSK but they have different sha256sums so can't be identical.
Kee's ABASIC_1.DSK is also Harry B. Fair.

Kee's ABASICSR.DSK is also the same as the one in the FHL directory.
That disk has a file called ABASIC.BIN which has "MICROWARE A/BASIC
COMPILER V2.1F" in it. I found a "7E7103" in it and a "BD7806" so it's
miniFLEX.

I suspect that "ABASIC  (c) 1982  Harry B. Fair" is not MICROWARE
A/BASIC, so be careful. 
Cheers, Ian.
#+end_src

*** RT/68MX Systems Manual

**** Index

***** Section 0 - Preliminaries

- Introduction 0-0
- Overview

***** Section 1 - Console Monitor

- Console Monitor Mode
- Error Codes
- Command Descriptions
- Program Abort

***** Section 2 - Single Task Mode

- Single Tasking mode

***** Section 3 - Multiprogramming

- Overview of Multiprogramming
- Tasks

***** Section 4 - RT/68 Multitasking Executive

- Task Status Table
- Task Status Byte
- Time Slices
- Task Selection
- Task Switching

***** Section 5 - Interrupt System

- Interrupt Processing
- Hardware Interrupt Considerations
- Hardware-caused Interrupt Errors
- Interrupt Handling in Single Task Mode
- Timed Task Interrupts
- Real Time Reference Clock
- Interrupt Service Time

***** Section 6 - Task Design

- Task Programming techniques
- System Planning
- Use of System Subroutines
- Utilizing System Data Values
- Position Independent Code
- Reentrant Code

***** Section 7 - Hardware Considerations

- RT/68 Hardware Configuration
- ROM Installation
- ROM Specifications

***** Section 8 - Input/Output System

- RT/68 I/O System

***** Appendix -

- Tape Format Data
- Interfacing to RT/68 Subroutines
- RT/68 Program Listing
- Sample and Utility Programs

**** Copyright (c) 1977 The Microware Systems Corporation

The RT/68 program is copyright by Microware
Systesm Corp. It may not be reproduced in any form
without express written permission.

Sale of this book or the RT/68 read-only-memory unit
conveys no rights, liceneses or priveleges to the pur-
chaser other than for use in a single computer system
owned by the purchaser.

The information in this manual is accurate to the best
of our knowledge, however we can assume no liability
other than the price of the product.

Mikbug(TM) is a register trademark of Motorola, Inc.

The Microware Systems Corporation
P. O. Box 954
Des Moines, Iowa 50311
/(515) 279-9856



Third Edition

Part Number RT68MXM

**** Section 0 - Preliminaries

***** Introduction 0-0
***** Overview

**** Section 1 - Console Monitor

***** Console Monitor Mode
***** Error Codes
***** Command Descriptions
***** Program Abort

**** Section 2 - Single Task Mode

***** Single Tasking mode

**** Section 3 - Multiprogramming

***** Overview of Multiprogramming

    The RT/68 system is provided on a MCM6830D mask-
progammed read-only-memory that is a direct replacement
for the Mikbug(TM) ROM used in many M6800 systems. In
addition to the functions performed by Mikbug(TM), the
RT/68 ROM contains a 16-task real-time multiprogramming
operating system.

    RT/68 provides three modes which are mutually exclusive:
Console Monitor to load, save and debug programs; Single
Task Mode to execute existing Mikbug(TM) software without
modification; and Multi-Task Mode which is the real time
multiprogramming mode.

    Sections of this manual are devoted to each of these
modes. In addition, a source listing and information on
installing and interfacing the ROM is included.

    There are many subroutines in the ROM that may be
called from a user program that can substantially save
time and memory. An examination of the listing and the
list of subroutines in the appendix can provice information
on interfacing to these subroutines.

***** Tasks

**** Section 4 - RT/68 Multitasking Executive

***** Task Status Table
***** Task Status Byte
***** Time Slices
***** Task Selection
***** Task Switching

**** Section 5 - Interrupt System

***** Interrupt Processing
***** Hardware Interrupt Considerations
***** Hardware-caused Interrupt Errors
***** Interrupt Handling in Single Task Mode
***** Timed Task Interrupts
***** Real Time Reference Clock
***** Interrupt Service Time

**** Section 6 - Task Design

***** Task Programming techniques
***** System Planning
***** Use of System Subroutines
***** Utilizing System Data Values
***** Position Independent Code
***** Reentrant Code

**** Section 7 - Hardware Considerations

***** RT/68 Hardware Configuration
***** ROM Installation
***** ROM Specifications

**** Section 8 - Input/Output System

***** RT/68 I/O System

**** Appendix -

***** Tape Format Data
***** Interfacing to RT/68 Subroutines
***** RT/68 Program Listing

#+begin_src bash
# f9dasm
asl -i . -L rt68mx.asm
# SEE ALSO
#        plist(1), pbind(1), p2hex(1), p2bin(1)
p2hex -F Moto -r \$-\$ lilbug.p
#+end_src

#+begin_src asm

 *[ Start ]**********************************************************************
 	NAM  RT68-V2	* 
 	
 *  <ESC> 1 <ESC> ! python3 ~/dev/python/asm-indent.py ~/dev/MC6800/r/rt68mx.asm <ENTER>
 
 *	****************
 *	*	       *
 *	*     RT/68    *
 *	*      MX      *
 *	*	       *
 *	****************
 *
 * RT/68MX REAL TIME OPERATING SYSTEM
 * (REVISED VERSION OF RT/68MR)
 *
 * COPYRIGHT (C) 1976,1977
 * THE MICROWARE SYSTEMS CORPORATION
 *
 * RT/68 LISTING AND OBJECT MAY NOT BE
 * REPRODUCED IN ANY FORM WITHOUT
 * EXPRESS WRITTEN PERMISSION.
 
 * MEMORY DEFINITIONS
 
 * RT/68 EXECUTIVE USES 12 BYTES OF RAM
 * BEGINNING AT 0, THESE ARE NOT NEEDED
 * IN SINGLE TASK MODE AND MAY BE
 * USED FOR ANY OTHER PURPOSE.
 	ORG  0 	* 
 SYSMOD	RMB  1  	* RT MODE 0=USER 1=EXEC
 CURTSK	RMB  1  	* TASK CURRENTLY ACTIVE
 TIMREM	RMB  1  	* TASK TIME REMAINING
 TSKTMR	RMB  2  	* TIMED TASK COUNTER
 CLOCK	RMB  2  	* RT CLOCK COUNTER
 INTREQ	RMB  1  	* INTERRUPT REQUEST FLAG
 TSKTMP	RMB  1  	* RT EXEC TEMP VAL
 PTYTMP	RMB  1  	* RT EXEC TEMP VAL
 TIMTSK	RMB  1  	* TIMED TASK INTR STATUS
 SYSPTY	RMB  1  	* SYS PRIORITY LEVEL
 
 	ORG  $A000	* 
 IRQTSK	RMB  2  	* IRQ TASK/VECTOR
 BEGADR	RMB  2  	* 
 ENDADR	RMB  2  	* 
 NMITSK	RMB  2  	* NMI TASK/VECTOR
 SPTMP	RMB  2  	* SP TMP VAL
 RTMOD	RMB  1  	* RT MODE FLAG
 BKPOP	RMB  1  	* BKPT OPCODE/FLAG
 BKPADR	RMB  2  	* BKPT ADDRESS
 RELFLG	RMB  1  	* SWI FLAG
 ERRFLG	RMB  1  	* ERROR FLAG/CODE
 XTMP	RMB  2  	* 
 IOVECT	RMB  2  	* ACIA ADDRESS VECTOR
 
 	ORG  $A042	* 
 STACK	EQU  *  	* MONITOR STACK
 
 * TASK STATUS TABLE
 *
 * CONSISTS OF 16 3-BYTE TASK STATUS WORDS, ONE FOR
 * EACH POSSIBLE TASK. EACH TASK STATUS WORD CONTAINS
 * A TASK STATUS BYTE (TSB) AND A 2-BYTE TASK STACK
 * POINTER (TSP)
 *
 * THE TSB IS DEFINED AS FOLLOWS:
 *
 *	BIT 7	1=TASK ON	0=TASK OFF
 *	BIT 6-3	TIME LIMIT IN TICKS (0-15)
 *	BIT 2-0	TASK PRIORITY (0-7)
 *
 * THE TSP IS THE VALUE OF THE TASK'S STACK
 * POINTER FOLLOWING THE LAST INTERRUPT, AND
 * THEREFORE POINTS TO THE COMPLETE MPU
 * REGISTER CONTENTS AT THE TIME THE TASK WAS
 * INTERRUPTED. TO RESTART A TASK THE EXEC
 * INITIALIZES THE SP FROM THE TSP AND
 * EXECUTES AN RTI INSTRUCTION
 *
 	ORG  $A050	* 
 TSKTBL	RMB  48  	* 
 
 * DEFINE PERIPHERIAL REGISTERS
 	ORG  $8004	* 
 PIADA	RMB  1  	* 
 PIACA	RMB  1  	* 
 PIADB	RMB  1  	* 
 PIACB	RMB  1  	* 
 ACIACS	RMB  1  	* 
 ACIADB	RMB  1  	* 
 
 	ORG  $E000	* 
 * TAPE LOAD SUBROUTINE
 *
 * READS MIKBUG(TM) FORMATTED OBJECT TAPES
 * INTO RAM.
 *
 * READER DEVICE IS CONTROLLED BY EITHER ASCII
 * CONTROL CODES OR PIA READER CONTROL OUTPUT
 * OUTPUT.
 *
 * TWO ERRORS ARE CHECKED: CHECKSUM AND
 * NO CHANGE
 LOAD	LDAB #$3C	* TAPE ON CONSTANTS XXXXXXXX
 	LDAA #$11	* READER ON CODE
 	BSR  RDRCON	* LET IT ROLL
 LOAD2	BSR  INCH	*
 	CMPA #'S 	* LOOK FOR START OF BLOCK
 	BNE  LOAD2	* BRA IF NOT
 	BSR  INCH	* 
 	CMPA #'9 	* END OF FILE?
 	BNE  LOAD4	* BRA IF NOT
 LOAD3	LDAB #$34	* TAPE OFF CONSTANTS XXXXXXXX
 	LDAA #$13	* 
 RDRCON	STAB PIACB	* PIA READER CTRL XXXXXXXX
 	BRA  OUTCH	* ASCII TAPE CONTROL
 LOAD4	CMPA #'1	* S1 DATA RECORD? XXXXXXXX
 	BNE  LOAD2	* BRA IF NOT, LOOK AGAIN
 	CLRB		* ACCB WILL GENERATE CHKSUM
 	BSR  BYTE	* PICK UP BYTE COUNT
 	SUBA #2 	* LESS 2 FOR THE BLOCK ADDR
 LOAD5	STAA BEGADR	* SAVE IT XXXXXXXX
 	BSR  BADDR	* GET BLOCK START ADDR IN X
 
 * LOOP TO READ DATA BLOCK
 LOAD6	BSR  BYTE	* GET A DATA BYTE XXXXXXXX
 	DEC  BEGADR	* DECR BYTE COUNT
 	BEQ  LOAD7	* BRA IF LAST BYTE
 	STAA 0,X 	* PUT IN MEMORY
 	CMPA 0,X 	* BE SURE IT CHANGED
 	BNE  LDMERR	* BRA TO ERROR- MUST BE ROM!!
 	INX		* NEXT ADDR
 	BRA  LOAD6	* NEXT BYTE
 
 * B ADDS CHKSM FROM TAPE TO CALCULATED CHKSUM,
 * SO BY ADDING ONE IT SHOULD ZERO
 LOAD7	INCB		* (LABEL/NM only?)
 	BEQ  LOAD2	* BRA IF IT DID
 	LDAA #$32	* TOO BAD, GET THE ERROR CODE
 	BRA  LODERR	* 
 LDMERR	LDAA #$31	* NO CHANGE ERROR CODE XXXXXXXX
 LODERR	STAA ERRFLG	*
 	BRA  LOAD3	* 
 
 * BUILD 4 HEX CHAR VALUE (ADDRESS)
 * RETURNS VALUE IN XR
 BADDR	BSR  BYTE	* INPUT 2 LEFT CHRS XXXXXXXX
 	STAA ENDADR	* 
 	BSR  BYTE	* INPUT 2 RIGHT CHRS
 	STAA ENDADR+1	* 
 	LDX  ENDADR	* 
 	RTS		* 
 
 * INPUT A BYTE (2 HEX CHARS)
 * RETURNS BINARY VALUE IN ACC A
 
 BYTE	PSHB INPUT	* 2 HEX CHAR XXXXXXXX
 	BSR  INHEX	* LEFT HEX CHAR
 	ASLA		* 
 	ASLA		* 
 	ASLA		* 
 	ASLA		* 
 	TAB		* 
 	BSR  INHEX	* RIGHT HEX CHAR
 	ABA		* 
 	PULB		* 
 	PSHA		* 
 	ABA		* 
 	TAB		* 
 	PULA		* 
 	RTS		* 
 	NOP		* 
 
 * HEX OUTPUT AUX SUBROUTINES
 OUTHL	LSRA		* (LABEL/NM only?)
 	LSRA		* 
 	LSRA		* 
 	LSRA		* 
 OUTHR	ANDA #$F  	*
 	ADDA #$30	* 
 	CMPA #$39	* 
 	BLS  OUTCH	* 
 	ADDA #$7 	* 
 
 OUTCH	JMP  OUT1CH	*
 INCH	JMP  IN1CHR	*
 
 * PRINT DATA STRING POINTED TO BY XR
 * AND ENDING WITH ASCII EOT ($04)
 PDATA2	BSR  OUTCH	*
 	INX		* 
 PDATA1	LDAA 0,X	* SUBR ENTRY POINT XXXXXXXX
 	CMPA #4 	* 
 	BNE  PDATA2	* 
 	RTS		* 
 
 *
 * CONSOLE MEMORY DUMP SUBROUTINE
 *
 * PRINTS BEG ADDR AND 16 BYTES OF DATA ON EACH LINE
 * STARTING ADDR IN BEGADR
 * ENDING ADDR IN ENDADR
 *
 DUMP	JSR  CRLF	* CR AND LF XXXXXXXX
 	LDX  #BEGADR	* 
 	BSR  OUT4HS	* PRINT BEGINNING ADDR
 	LDAB #16 	* BYTE COUNT FOR LINE
 	LDX  BEGADR	* GET BEG ADDR
 DUMP1	BSR  OUT2HS	* PRINT A BYTE XXXXXXXX
 	DEX		* 
 	CPX  ENDADR	* DONE YET?
 	BNE  DUMP2	* BRA IF NOT
 	RTS		* 
 DUMP2	INX  ADV	* X TO NEXT BYTE XXXXXXXX
 	DECB		* DEC LINE BYTE COUNT
 	BNE  DUMP1	* BRA IF LINE NOT DONE
 	STX  BEGADR	* UPDATE BEGADR TO CURRENT ADDR
 	BRA  DUMP	* 
 
 HBAD	LDAA #$33	* INHEX ERROR RETURN XXXXXXXX
 	STAA ERRFLG	* 
 	RTS		* 
 
 * INPUT HEX CHARACTER, IF CHAR IS NOT
 * HEX, THE ERROR FLAG IS SET TO THE
 * ERROR CODE ($33 - ASCII 1)
 INHEX	BSR  INCH	* INPUT ONE HEX CHAR XXXXXXXX
 	SUBA #$30	* 
 	BCS  HBAD	* 
 	CMPA #9 	* 
 	BLS  IHRET	* 
 	SUBA #7 	* 
 	BCS  HBAD	* 
 	CMPA #15 	* 
 	BHI  HBAD	* 
 IHRET	RTS		* (LABEL/NM only?)
 
 	NOP		* 
 	NOP		* 
 
 * OUTPUT BYTE (TWO HEX CHARS) POINTED
 * TO BY XR
 OUT2H	LDAA 0,X  	*
 	BSR  OUTHL	* 
 	LDAA 0,X 	* 
 	INX		* 
 	BRA  OUTHR	* 
 
 * OUTPUT 4 HEX CHARS AND SPACE
 OUT4HS	BSR  OUT2H	*
 
 * OUTOUT 2 HEX CHARS AND SPACE
 OUT2HS	BSR  OUT2H	*
 
 * OUTPUT A SPACE
 OUTS	LDAA #$20	*
 BOUT	BRA  OUTCH	*
 
 * PRINT CONTENTS OF STACK
 * FORMAT:
 * SP CC B A XR PC
 PRSTAK	BSR  CRLF	* PRINT CF+LF XXXXXXXX
 	LDX  #SPTMP	* 
 	BSR  OUT4HS	* PRINT SP
 	LDX  SPTMP	* 
 PRSTK	INX  ENTRY	* TO PRINT TASK STACK XXXXXXXX
 	BSR  OUT2HS	* PRINT CC
 	BSR  OUT2HS	* PRINT ACC B
 	BSR  OUT2HS	* PRINT ACC A
 	BRA  PRSTK2	* BRA OVER PATCH
 CONTRL	JMP  CONENT	* PATCH FOR ADDR ALIGNMENT XXXXXXXX
 PRSTK2	BSR  OUT4HS	* PRINT XR XXXXXXXX
 	BRA  OUT4HS	* PRINT PC +RTS
 
 * WRITE OBJECT TAPE SUBROUTINE
 *
 * GENERATES MIKBUG(TM) FORMATTED TAPES
 * ON SYSTEM TAPE DEVICE (PAPER TAPE,
 * AUDIO CASSETTE, ETC.)
 *
 * BEGINNING ADDRESS OF DATA IN "BEGADR"
 * ENDING ADDRESS IN "ENDADR"
 *
 * ENTRY POINT IS "TAPOUT" - E0EE
 
 * AUX. SUBR. TO OUTPUT BYTE + UPDATE
 * CHECKSUM.
 TAPAUX	ADDB 0,X  	*
 	BRA  OUT2H	* 
 
 TAPOUT	LDAA #$12	* TAPE ON CODE XXXXXXXX
 	BSR  OUTCH	* 
 *OUTPUT 60 NULL CHARS TO GENERATE
 * EITHER A 6" LEADER FOR PAPER TAPE "
 * OR A 2 SECOND TAPE SPEEDUP DELAY
 * (AT 30CPS) FOR AUDIO CASSETTES
 	LDAB #60 	* LEADER/DELAY NULL COUNT
 OUTLDR	CLRA		* (LABEL/NM only?)
 	BSR  JOUT1C	* 
 	DECB		* 
 	BNE  OUTLDR	* 
 
 * SUBTRACT BEGADR FROM ENDADR
 TOUT1	LDX  #BEGADR	*
 	LDAA 2,X 	* 
 	LDAB 3,X 	* 
 	SUBB 1,X 	* 
 	SBCA 0,X 	* 
 	BCC  TOUT2	* BRA IF BEG < END TO DUMP
 	LDAA #$14	* PUNCH OFF CODE
 JOUT1C	JMP  OUTCH	*
 
 * CALCULATE BYTE COUNT
 TOUT2	BNE  TOUT3	* BRA IF HIGH BYTE NONZERO XXXXXXXX
 	CMPB #16 	* 
 	BCS  TOUT4	* BRA IF BLOCK < 16 BYTES
 TOUT3	LDAB #15	* SET FULL BLOCK XXXXXXXX
 TOUT4	ADDB #4		* ADD FOR B.C. + BEG ADDR. XXXXXXXX
 
 * OUTPUT BLOCK HEADER
 	BSR  CRLF	* OUTPUT CR,LF,NULLS
 	INX		* 
 	BSR  JPDATA	* OUTPUT S,1
 	PSHB		* SAVE BYTE COUNT
 	TSX		* 
 	CLRB		* CLEAR CHECKSUM
 	BSR  TAPAUX	* PRINT BYTE CNT
 	PULA		* 
 	SUBA #3 	* UPDATE BYTE COUNT
 	PSHA		* 
 	LDX  #BEGADR	* 
 	BSR  TAPAUX	* OUTPUT BEG. ADDR
 	BSR  TAPAUX	* 
 
 * LOOP TO OUTPUT ONE BLOCK OF DATA
 	LDX  BEGADR	* XR POINTS TO CURRENT DATA BYT
 TOUT5	BSR  TAPAUX	* OUTPUT BYTE XXXXXXXX
 	PULA		* 
 	DECA		* DECR BYTE COUNT
 	PSHA		* 
 	BNE  TOUT5	* BRA IF BYTE CNT NOT ZERO
 
 	INS		* 
 	STX  BEGADR	* SAVE CURRENT ADDR
 	COMB		* COMPL CHKSUM
 	PSHB		* 
 	TSX		* 
 	BSR  TAPAUX	* OUTPUT CHKSUM
 	INS		* 
 	BRA  TOUT1	* 
 
 * SUBROUTINE TO PRINT CR + LF
 CRLF	LDX  #CRLSTR	*
 JPDATA	JMP  PDATA1	*
 
 * RT/68 CONSOLE MONITOR PROGRAM
 *
 * ACCEPTS COMMANDS FORM THE CONSOLE DEVICE
 * AND EXECUTES THE APPROPRIATE FUNCTION.
 
 * ENTRY POINT FOR RESTART
 INIT	LDS  #STACK	* INITIALIZE PERIPHERALS XXXXXXXX
 	STS  SPTMP	* 
 	LDX  #$8000	* 
 	STX  IOVECT	* INIT ACIA VECTOR
 * INITIALIZE CONTROL PIA
 	INC  4,X 	* 
 	LDAB #$16	* 
 	STAB 5,X 	* 
 	INC  4,X 	* 
 	LDAA #$05	* 
 	STAA 6,X 	* 
 	LDAA #$34	* 
 	STAA 7,X 	* 
 * INITIALIZE ACIA AT $8000
 	LDAA #3 	* 
 	STAA 0,X 	* 
 	DECB		* 
 	STAB 0,X 	* SET ACIA CSR
 CONENT	CLR  BKPOP	* CONSOLE ROUTINE ENTRY POINT XXXXXXXX
 	CLR  RTMOD	* 
 CONSOL	CLR  ERRFLG	*
 	LDS  #STACK	* INIT SP
 	BSR  CRLF	* 
 	LDAA #'$ 	* PRINT PROMPT
 	BSR  OUTEEE	* 
 	BSR  INEEE	* INPUT COMMAND CODE
 
 * COMMAND TABLE LOOKUP/EXECUTE LOOP
 * SEARCHES FOR COMMAND CODE ON TABLE TO OBTAIN
 * FUNCTION SUBROUTINE ADDRESS.
 	LDX  #CMDTBL-3	* INIT X TO BEGINNING OF TABL
 CMSRCH	INX  ADV	* TO NEXT ENTRY XXXXXXXX
 	INX		* 
 	INX		* 
 	LDAB 0,X 	* GET CODE FROM TABLE
 	BEQ  CMDERR	* IF ZERO, END OF TABLE
 	CBA		* COMMAND CODE MATCH COMPARE
 	BNE  CMSRCH	* BACK TO ADV IF NOT
 	LDX  1,X 	* GET CMND SUBR ADDR FROM TABLE
 	JSR  0,X 	* DO IT
 TSTENT	BSR  ERTEST	* TEST FOR ERROR XXXXXXXX
 GOCON	BRA  CONSOL	* GET ANOTHER CMND XXXXXXXX
 
 CMDERR	LDAB #'6	* ILLEGAL COMMAND CODE XXXXXXXX
 	BRA  ERROR	* 
 
 * SUBR TO SET 0R REMOVE BREAKPOINTS
 SETBKP	LDAA BKPOP	* GET BKPT FLAG OR OPCODE XXXXXXXX
 	BEQ  SBRET	* IF = 0, NO BKPT ACTIVE
 	LDX  BKPADR	* GET ADDR
 * SWAP FLAG/OPCODE
 	LDAB 0,X 	* 
 	STAA 0,X 	* 
 	STAB BKPOP	* 
 SBRET	RTS		* (LABEL/NM only?)
 
 * "D" DUMP COMMAND
 DMPCOM	BSR  GET2AD	*
 	JMP  DUMP	* 
 
 INEEE	JMP  IN1CHR	*
 
 * SUBR TO PREPARE FOR USER PROGRAM
 * EXECUTION. CALLED BY G, E, & S COMMANDS
 *
 SETRUN	BSR  SETBKP	* SET BKPT IF ANY XXXXXXXX
 	LDAB #$1E	* 
 	LDAA RTMOD	* TEST IF MULTITASK MODE
 	BEQ  SETRN2	* BRA IF NOT MULTI
 	INCB		* ENABLE RT CLOCK INTR
 	CLRA		* 
 	STAA SYSMOD	* 
 SETRN2	LDAA PIADA	*
 	STAB PIACA	* 
 RETURN	RTS		* (LABEL/NM only?)
 
 * "B" BREAKPOINT COMMAND ROUTINE
 BKPCOM	CLR  BKPOP	*
 	BSR  GETADR	* 
 	STX  BKPADR	* 
 	LDAA #$3F	* 
 	STAA BKPOP	* 
 	RTS		* 
 
 OUTEEE	JMP  OUT1CH	*
 
 * SUBR TO READ ONE OR TWO ADDRESS
 * PARAMETERS, COMMA LEADS ADDRESSES,
 * (CR) CANCELS COMMAND
 GET2AD	BSR  GETADR	* GET TWO ADDRESSES XXXXXXXX
 	STX  BEGADR	* 
 
 GETADR	BSR  INEEE	* GET ONE ADDRESS XXXXXXXX
 	LDAB #$34	* 
 	CMPA #$0D	* 
 	BEQ  CONSOL	* 
 	CMPA #', 	* 
 	BNE  ERROR	* 
 	JSR  BADDR	* 
 
 * ERROR TEST SUBROUTINE
 ERTEST	LDAB ERRFLG	*
 	BEQ  RETURN	* 
 
 * ERROR HANDLER, PRINTS MESSAGE
 * AND ERROR CODE
 ERROR	LDX  #ERRMSG	*
 	JSR  PDATA1	* 
 	TBA		* 
 	BSR  OUTEEE	* 
 	BRA  GOCON	* 
 
 * "E" EXECUTE SINGLE TASK COMMAND
 EXCOM	BSR  GETADR	*
 	BSR  SETRUN	* 
 	LDX  ENDADR	* 
 	JMP  0,X 	* 
 
 * "G" GO TO USER PGM OR RETURN FROM
 * BREAKPOINT COMMAND ROUTINE
 GOCOM	LDS  SPTMP	*
 	BSR  SETRUN	* 
 	RTI		* 
 
 * "P" WRITE TAPE COMMAND
 PUNCOM	BSR  GET2AD	*
 	JMP  TAPOUT	* 
 
 * "S" COMMAND
 * ACTIVATES AND INITIALIZES RT/68
 * EXECUTIVE
 SYSCOM	CLR  RELFLG	*
 	LDAA #1 	* 
 	STAA RTMOD	* 
 	LDX  #PTYTMP	* 
 CLOOP	CLR  0,X  	*
 	DEX		* 
 	BNE  CLOOP	* 
 	STAA 0,X 	* 
 	BSR  SETRUN	* 
 	JMP  EXEC02	* JUMP TO RT EXEC ENTRY
 
 * "M" MEMORY EXAMINE/CHANGE ROUTINE
 * AFTER BEGINNING ADDR IS ENTERED, PGM
 * PRINTS ADDR AND DATA IN HEX:
 *	AAAA DD
 * A SLASH AND NEW HEX DATA CHANGES LOACTION,
 * A (LF) OPENS NEXT ADDR, AND A (CR) CLOSES
 * FUNCTION
 MEMCOM	BSR  GETADR	* GET BEG ADDR XXXXXXXX
 
 * EXAMINE/CHANGE LOOP
 MEM1	JSR  CRLF	*
 MEM2	LDAA #$0D	* PRINT LF XXXXXXXX
 	BSR  OUTEEE	* 
 	LDX  #ENDADR	* 
 	JSR  OUT4HS	* PRINT ADDRESS
 	LDX  ENDADR	* 
 	JSR  OUT2H	* PRINT CONTENTS
 	STX  ENDADR	* 
 	JSR  INEEE	* INPUT DELIMITER
 	CMPA #$0A	* 
 	BEQ  MEM2	* BRA IF LF TO OPEN NEXT
 	CMPA #'/ 	* 
 	BEQ  MEM3	* BRA IF CHANGE
 	RTS		* 
 
 * CHANGE MEMORY LOCATION
 MEM3	JSR  BYTE	* READ NEW DATA XXXXXXXX
 	BSR  ERTEST	* 
 	DEX		* 
 	STAA 0,X 	* STORE NEW DATA
 	CMPA 0,X 	* TEST FOR CHANGE
 	BEQ  MEM1	* BRA IF OK TO OPEN NEXT
 	LDAB #$35	* ERROR CODE
 	BRA  ERROR	* 
 
 *	REAL TIME OPERATING SYSTEM COMPONENTS
 *
 * CONSISTS OF:
 *
 *	INTERRUPT PROCESSORS
 *	TASK EXECUTIVE
 *	AUX. SUBROUTINES
 *
 
 
 * BREAKPOINT SERVICE ROUTINE
 RUNBKP	TSX  GET	* SP IN XR XXXXXXXX
 	BSR  ADJSTK	* DECR PC ON STACK
 	LDX  5,X 	* GET TASK PC OFF STACK
 	CPX  BKPADR	* COMPARE TO PRESET ADR
 	BEQ  RUNBK2	* BRA IF SAME
 	LDAB #$37	* SET ERROR FLAG
 	STAB ERRFLG	* 
 RUNBK2	JSR  SETBKP	* REMOVE BKPT OPCODE XXXXXXXX
 	LDAA #$16	* 
 	STAA PIACA	* OFF RT CLOCK + ABORT INTR
 	STS  SPTMP	* SAVE TASK SP
 	JSR  PRSTAK	* DUMP STACK
 	JMP  TSTENT	* ENTER CONSOLE MONITOR
 
 * SUBR TO DECREMEMT PC ON STACK
 ADJSTK	TST  0,X  	*
 	BNE  ADSTK2	* 
 	DEC  5,X 	* 
 ADSTK2	DEC  6,X  	*
 	RTS		* 
 
 * SWI ENTRY POINT, DETERMINES WHETHER
 * BREAKPOINT OR PGM RELEASE FUNCTION
 
 SINT	EQU  *  	* SWI VECTOR DESTINATION
 	LDAA RELFLG	* GET PGM RELEASE FLAG
 	BEQ  RUNBKP	* EXEC BKPT IF NOT SET
 	CLR  RELFLG	* RESET FLAG
 	CLRB		* 
 	BRA  EXEC09	* GO TO EXEC TO SWAP
 
 * IRQ INTERRUPT ENTRY POINT
 * INCLUDES LOGIC TO DETECT AND CORRECT
 * INTERRUPT ERROR OCCURRING WHEN SWI +
 * NMI OCCUR SIMULTANEOUSLY. (SEE P. A-10
 * OF M6800 APPLICATIONS MANUAL)
 
 IRQ	EQU  *  	* IRQ VECTOR DESTINATION
 	LDAA RELFLG	* GET SWI FLAG
 	BNE  INTBAD	* BRA TO ERR CORR. IF SET
 	LDX  #IRQTSK	* PTR TO IRQ VECTOR/STATUS
 	BRA  RUNINT	* GOTO INTR SERVICE
 
 * CORRECT SWI-IRQ COINC. ERROR
 INTBAD	TSX		* (LABEL/NM only?)
 	BSR  ADJSTK	* DECR TASK PC ON STACK
 
 * NMI INTERRUPT HANDLER
 *
 * TEST CONTROL PIA FOR ABORT OR CLOCK
 * INTERRUPT AND PROCESS SAME
 * IF NOT, EXECUTES USER INTERRUPT
 NMI	EQU  *  	* NMI VECTOR DEST.
 	LDAA PIACA	* GET PIA STATUS REG
 	LDAB PIADA	* CLEAR PIA INTR FLGS
 	ASLA		* 
 	BMI  RUNBK2	* BRA IF ABORT INTR
 	BCC  NMI5	* BRA IF USER INTR
 * HERE IF CLOCK INTR ONLY
 	LDAA RTMOD	* TEST SYS MOD
 	BEQ  NMI5	* BRA TO USER INTR IF NOT
 	LDX  CLOCK	* 
 	INX		* 
 	STX  CLOCK	* 
 * UPDATE TIMED TASK STATUS
 	LDX  TSKTMR	* GET THE TIMED TASK COUNTER
 	BEQ  NMI3	* BRA IF NOT ACTIVE
 	DEX		* DECR THE COUNTER
 	STX  TSKTMR	* 
 	BNE  NMI3	* BRA IF NOT EXPIRED
 	LDAA TIMTSK	* GET TIMED TASK STAT BYTE
 	BRA  RNINT3	* RUN AS INTERRUPT
 * UPDATE REMAINING TIME OF CURRENT TASK
 NMI3	LDAA TIMREM	* GET TIME LEFT XXXXXXXX
 	BEQ  NMI4	* BRA IF UNLIMITED
 	DECA		* 
 	STAA TIMREM	* 
 	BEQ  EXEC01	* BRA TO EXEC IF TIME UP
 NMI4	LDAA INTREQ	* TEST FOR PENDING INTR. XXXXXXXX
 	BNE  EXEC01	* 
 	RTI		* 
 NMI5	LDX  #NMITSK	* GET NMI STAT PTR XXXXXXXX
 
 * GENERAL INTERRUPT PRESERVICE
 * SELECTS PROPER MODE, AND EITHER
 * RUNS OR SCHEDULES INTERRUPT SERVICE
 * TASK ACCORDING TO THE APPROPRIATE
 * STATUS BYTE
 RUNINT	LDAA RTMOD	*
 	BNE  RNINT2	* BRA IF MULTITASK MODE
 	LDX  0,X 	* GET VECTOR
 	JMP  0,X 	* EXECUTE SAME AS MIKBUG
 
 RNINT2	LDAA 0,X	* GET INTR STATUS BYTE XXXXXXXX
 RNINT3	BSR  TSKON	* TURN SERV. TASK ON XXXXXXXX
 	TSTA		* CHK IMMED OR DEFERRED
 	BPL  INTRET	* BRA IF DEFERRED
 	STAA INTREQ	* SET INTR REQ. FLAG
 * FALL THRU TO EXECUTIVE
 
 * RT/68 MULTI TASK EXECUTIVE PROGRAM
 *
 * SAVES CURRENT TASK STATUS IN TASK STATUS
 * TABLE, THEN SEARCHES THE TABLE FOR THE
 * HIGHEST PRIORITY RUNNABLE TASK AND STARTS
 * IT. IF THERE IS MORE THAN ONE RUNNABLE TASK
 * AT THE HIGHEST LEVEL, THE
 * EXECUTIVE WII RUN THEM ROUND ROBIN
 
 * TEST MODE TO PREVENT MULTIPLE
 * EXECUTION OF EXEC BY INTERRUPTS
 EXEC01	LDAB SYSMOD	*
 	BNE  INTRET	* BRA IF EXEC ALREADY ACTIVE
 EXEC09	INCB SET	* EXEC MODE XXXXXXXX
 	STAB SYSMOD	* 
 * SAVE CURRENT TASK SP ON TABLE
 	LDAA CURTSK	* GET CURRENT TASK #
 	BSR  FNDTSB	* FIND ADDR OF TSB
 	STS  1,X 	* SAVE SP
 
 * INITIALIZE EXEC TEMP VALUES
 * PTYTMP = HIGHEST PRIORITY FOUND
 * TSKTMP = TASK # FOR ABOVE
 EXEC02	CLRA		* (LABEL/NM only?)
 	STAA INTREQ	* 
 	STAA PTYTMP	* 
 	STAA TSKTMP	* 
 	LDAA CURTSK	* 
 
 * LOOP TO SEARCH THRU TABLE FOR
 * HIGHEST RUNNABLE TASK
 * STARTS WITH CURRENT TASK AND COUNTS
 * DOWN SO LAST TASK TESTED IS THE
 * CURRENT TASK # -1. THIS ALLOWS TASKS
 * AT THE SAME PRIORITY LEVEL TO EXECUTE
 * ROUND-ROBIN.
 EXEC03	BSR  FNDTSB	* FIND TSB XXXXXXXX
 	BPL  EXEC04	* BRA IF TASK OFF
 	ANDB #$07	* MASK PRIORITY
 	CMPB PTYTMP	* COMP. TO HIGHEST SO FAR
 	BCS  EXEC04	* BRA IF LOWER
 	STAB PTYTMP	* MAKE IT LATEST
 	TAB		* CHANGE SET TASK #
 	ORAB #$80	* SET FOUND FLAG
 	STAB TSKTMP	* 
 *ADVANCE TO NEXT TASK
 EXEC04	DECA		* (LABEL/NM only?)
 	ANDA #$0F	* 
 	CMPA CURTSK	* SEE IF LAST TASK
 	BNE  EXEC03	* BRA IF NOT FINISHED
 
 * CHECK IF TASK FOUND IS RUNNABLE
 	LDAB PTYTMP	* GET HI PRIORITY
 	CMPB SYSPTY	* COMPARE TO SYS PRIORITY
 	BCS  EXEC02	* SEARCH AGAIN IF LOWER
 	LDAA TSKTMP	* TEST FOUND FLAG
 	BPL  EXEC02	* BRA IF NOT SET
 
 * RUNNABLE TASK FOUND, SET SYSTEM
 * PARAMETERS TO RUN IT
 	ANDA #$0F	* 
 	STAA CURTSK	* SET TASK #
 	BSR  FNDTSB	* GET TASK TSB
 	LSRB		* EXTRACT TIME LIMIT
 	LSRB		* 
 	LSRB		* 
 	ANDB #$0F	* 
 	STAB TIMREM	* 
 	LDS  1,X 	* LOAD TASK SP
 * TEST FOR ANY INTERRUPT THAT OCCURRED
 * DURING EXEC MODE
 	LDAA INTREQ	* 
 	BNE  EXEC02	* 
 	CLR  SYSMOD	* SET USER MODE
 INTRET	RTI  RUN	* TASK XXXXXXXX
 
 * RT EXECUTIVE AUX. SUBROUTINES
 *
 * ALL ARE REENTRANT SUBROUTINES THAT
 * PASS PARAMETERS AS FOLLOWS:
 *
 * ENTRY: TASK # IN ACC A
 *
 * RETURN: TASK # IN ACC A
 *		TASK STATUS BYTE (NEW) IN ACC B
 *		ADDR OF TSB IN XR
 
 * SUBR TO TURN TASK ON
 TSKON	BSR  FNDTSB	*
 	ORAB #$80	* 
 RESTSB	STAB 0,X  	*
 	RTS		* 
 
 * SUBR TO TURN CURRENT TASK OFF
 CTSKOF	LDAA CURTSK	*
 
 * SUBR TO TURN TASK OFF
 TSKOFF	BSR  FNDTSB	*
 	ANDB #$7F	* 
 	BRA  RESTSB	* 
 
 * SUBR TO FIND TASK STATUS BYTE/WORD
 FNDTSB	PSHA		* (LABEL/NM only?)
 	ANDA #$0F	* 
 	TAB		* 
 	ASLA		* 
 	ABA		* 
 	ADDA #$50	* 
 	PSHA		* 
 	LDAA #$A0	* 
 	PSHA		* 
 	TSX		* 
 	LDAA 0,X 	* 
 	INS		* 
 	INS		* 
 	LDAB 0,X 	* 
 	PULA		* 
 	RTS		* 
 
 * CHARACTER AND BYTE I/O ROUTINES
 *
 * SELECTS INTERFACE TYPE (PIA OR ACIA)
 * ACCORDING TO THE LEVEL OF PIA INPUT CB5
 * IF ACIA TYPE IS SELECTED, THE ADDRESS
 * OF THE ACIA IS OBTAINED FROM "IOVECT"
 * WHICH WILL DEFAULT TO $8000
 
 * READ CHAR WITHOUT PARITY OR RUBOUT
 IN1CHR	BSR  INBYTE	* GET BYTE XXXXXXXX
 	ANDA #$7F	* STRIP PARITY BIT
 	CMPA #$7F	* TEST FOR RUBOUT
 	BEQ  IN1CHR	* AGAIN IF RUBOUT
 	RTS		* 
 
 * READ 8-BIT BYTE
 INBYTE	PSHB		* (LABEL/NM only?)
 	BSR  IOAUX	* SAVE XR + SAMPLE TYPE
 	BNE  ACIAIN	* 
 
 * PIA SOFTWARE UART ROUTINE -
 * INPUT ONE CHAR WITHOUT PARITY
 PIAIN	LDAA 4,X  	*
 	BMI  PIAIN	* WAIT FOR START BIT
 	CLR  6,X 	* SET 1/2 BIT TIME
 	BSR  STRTBT	* RESET TIMER
 	BSR  WAITBT	* WAIT FOR TIMER
 	LDAB #$04	* 
 	STAB 6,X 	* SET TIMER TO FULL BIT TIME
 	ASLB		* BIT COUNT=8
 * LOOP TO INPUT 8 DATA BITS
 PIAIN2	BSR  WAITBT	* WAIT BIT TIME XXXXXXXX
 	SEC		* 
 	ROL  4,X 	* SHIFT OUT DATA
 	RORA		* SHIFT IN A TO BUILD
 	DECB		* DECR BIT COUNT
 	BNE  PIAIN2	* BRA IF NOT DONE
 	BSR  WAITBT	* WAIT FOR STOP BIT
 CHKSTB	LDAB 6,X	* TEST FOR # STOP BITS XXXXXXXX
 	ASLB		* 
 	BPL  RESTOR	* 
 	BSR  WAITBT	* 
` * RESTORE REGISTERS + RETURN
 RESTOR	LDX  XTMP	*
 	PULB		* 
 	RTS		* 
 
 * ACIA CHAR INPUT ROUTINE
 ACIAIN	LDAB 0,X	* GET STAT REG XXXXXXXX
 	LSRB		* MOVE RDY BIT TO SIGN POS
 	BCC  ACIAIN	* WAIT IF NOT READY
 	LDAA 1,X 	* READ DATA
 	BRA  RESTOR	* BRA TO CLEANUP
 
 * I/O SETUP SUBROUTINE
 IOAUX	STX  XTMP	* SAVE XR XXXXXXXX
 	LDX  #$8000	* LOAD XR WITH PERIPH PTR
 	LDAB 6,X 	* TEST FOR ACIA OR PIA
 	BITB #$20	* 
 	BEQ  AUXRET	* BRA IF PIA
 	LDX  IOVECT	* GET ACIA ADDRESS
 AUXRET	RTS		* (LABEL/NM only?)
 
 * SUBR TO WAIT FOR 1 BIT TIME
 * AND RESET TIMER
 WAITBT	TST  6,X  	*
 	BPL  WAITBT	* 
 
 * SUBROUTINE TO START (RESET) BIT TIMER
 STRTBT	INC  6,X  	*
 	DEC  6,X 	* 
 	RTS		* 
 * OUTPUT 1 CHARACTER SUBROUTINE TO
 * PIA OR ACIA
 OUT1CH	PSHB SAVE	* ACC B XXXXXXXX
 	BSR  IOAUX	* SETUP FOR ROUTINE
 	BNE  ACOUT	* USE ACIA SUBR IF TRUE
 
 * PIA SOFTWARE UART CHAR OUTPUT
 	LDAB #4 	* 
 	STAB 4,X 	* SPACE FOR START BIT
 	STAB 6,X 	* SET TIMER FOR FULL
 	LDAB #10 	* INIT. BIT COUNTER
 	BSR  STRTBT	* RESET TIMER
 * BIT OUTPUT LOOP
 POUT1	BSR  WAITBT	* WAIT BIT TIME XXXXXXXX
 	STAA 4,X 	* SET BIT OUTPUT
 	SEC		* 
 	RORA		* SHIFT IN NEXT BIT
 	DECB		* DEC BYTE COUNT
 	BNE  POUT1	* BRA IF NOT LAST BIT
 	BRA  CHKSTB	* 
 
 * ACIA CHAR OUTPUT ROUTINE
 ACOUT	LDAB 0,X	* GET STAT REG XXXXXXXX
 	LSRB		* SHIFT RDY BIT TO C
 	LSRB		* 
 	BCC  ACOUT	* BRA IF NOT READY
 	STAA 1,X 	* STORE DATA
 	BRA  RESTOR	* GO CLEANUP
 
 * ERROR MESSAGE STRING
 ERRMSG	FCB  $20,'E,'R,'R,$20,4	* 
 
 * CR/LF AND TAPE HEADER STRING
 CRLSTR	FCB  $0D,$0A,0,0,0,4,'S,'1,4	* 
 
 *
 * COMMAND CODE/ADDRESS TABLE
 *
 CMDTBL	EQU  *  	* 
 	FCB  'B 	* 
 	FDB  BKPCOM	* 
 	FCB  'D 	* 
 	FDB  DMPCOM	* 
 	FCB  'E 	* 
 	FDB  EXCOM	* 
 	FCB  'G 	* 
 	FDB  GOCOM	* 
 	FCB  'L 	* 
 	FDB  LOAD	* 
 	FCB  'M 	* 
 	FDB  MEMCOM	* 
 	FCB  'P 	* 
 	FDB  PUNCOM	* 
 	FCB  'R 	* 
 	FDB  PRSTAK	* 
 	FCB  'S 	* 
 	FDB  SYSCOM	* 
 	FCB  $1B 	* (ESC) NEXT ROM OR USER DEFINE
 	FDB  $7000	* 
 	FCB  0 	* END
 
 *
 * INTERRUPT VECTORS
 *
 	FDB  IRQ 	* * FFF7 IRQ VECTOR
 	FDB  SINT	* * FFFA SWI VECTOR
 	FDB  NMI 	* * FFFC NMI VECTOR
 	FDB  INIT	* * FFFE RESTART VECTOR
 
 	END		* 
 
 * RAM
 * $0000 (at least 256 bytes?)
 * $8000 - 8003 ACIA
 * $8004 - RAM?
 * $A000 - RAM
 * ROM
 * $E000 ROM starts
 * $F000 ROM (4096 bytes, reset @FFFE)
 * $F000 ROM (4096 bytes, reset @FFFE)
 * $F000 ROM (4096 bytes, reset @FFFE)
 * I/O
 * PIAC $C000 ?
 * PIAD $D000 ? (6820/6821/6522)
 * ACIA $8000 ? (weird, 6850)
 *[ Fini ]***********************************************************************
 
#+end_src

***** Sample and Utility Programs


* -[ Fini ]------------------------------ ----------------------------------------
** Emacs Org-mode stuff
#+STARTUP: overview+
#+STARTUP: inlineimages
#+STARTUP: indent
#+CREATOR: Neil Cherry <ncherry@linuxha.com>
#+title: MP-A8 - SS50 Reproduction SWTPC MP-A8 68008 CPU Board
